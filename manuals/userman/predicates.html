<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">

<head>
	<meta http-equiv="content-type" content="application/xml+xhtml; charset=utf-8" />
	<title>Logtalk user manual: predicates</title>
	<link rel="stylesheet" href="../screen.css" type="text/css" media="screen"/>
	<link rel="stylesheet" href="../print.css" type="text/css" media="print"/>
</head>

<body>

<div class="top-left">Logtalk user manual</div> 
<div class="top-right">Predicates</div>
<div class="bottom-left"><span class="page"/></div> 
<div class="bottom-right"><span class="page"/></div>
<div class="navtop"><a href="../index.html">contents</a> &gt; <a href="index.html">user manual</a></div>

<h1>Predicates<span id="predicates_predicates"/></h1>

<p>
Predicate directives and clauses can be encapsulated inside objects and categories. Protocols can only contain predicate directives.
</p>

<h2>Declaring predicates<a id="predicates_declaring"></a></h2>

<p>
All object (or category) predicates that we want to access from other objects must be explicitly declared. A predicate declaration must contain, at least, a scope directive. Other directives may be used to document the predicate or to ensure proper compilation of the predicate definitions.
</p>
<p>
Predicate directives should always precede the corresponding predicate definitions and/or calls in the source files in order to ensure proper compilation.
</p>

<h3>Scope directives<a id="predicates_scope"></a></h3>

<p>
A predicate can be public, protected, or private. Public predicates can be called from any object. Protected predicates can only be called from the container object or from a container descendant. Private predicates can only be called from the container object.
</p>
<p>
The scope declarations are made using the directives <a title="Consult reference manual" href="../refman/directives/public1.html"><code>public/1</code></a>, <a title="Consult reference manual" href="../refman/directives/protected1.html"><code>protected/1</code></a>, and <a title="Consult reference manual" href="../refman/directives/private1.html"><code>private/1</code></a>. For example:
</p>
<pre>:- public(init/1).

:- protected(valid_init_option/1).

:- private(process_init_options/1).</pre>
<p>
Note that we do not need to write scope declarations for all defined predicates. If a predicate does not have a scope declaration, it is assumed that the predicate is private, although it will be invisible to the reflection methods and to the message and error handling mechanisms. One exception is local, dynamic predicates: explicitly declaring them as private predicates allows the Logtalk compiler to generate optimized code for them.
</p>

<h3>Mode directive<a id="predicates_mode"></a></h3>

<p>
Many predicates cannot be called with arbitrary arguments with arbitrary instantiation status. The valid arguments and instantiation modes can be documented by using the <a title="Consult reference manual" href="../refman/directives/mode2.html"><code>mode/2</code></a> directive. For instance:
</p>
<pre>:- mode(member(?term, +list), zero_or_more).</pre>
<p>
The first argument describes a valid calling mode. The minimum information will be the instantiation mode of each argument. There are four possible values (described in <a title="ISO Prolog Standard" href="../bibliography.html#ISO95">[ISO 95]</a>):
</p>
<dl>
	<dt><code>+</code></dt>
		<dd>Argument must be instantiated.</dd>
	<dt><code>-</code></dt>
		<dd>Argument must be a free (non-instantiated) variable.</dd>
	<dt><code>?</code></dt>
		<dd>Argument can either be instantiated or free.</dd>
	<dt><code>@</code></dt>
		<dd>Argument will not be modified.</dd>
</dl>
<p>
These four mode atoms are also declared as prefix operators by the Logtalk compiler. This makes it possible to include type information for each argument like in the example above. Some of the possible type values are: <code>event</code>, <code>object</code>, <code>category</code>, <code>protocol</code>, <code>callable</code>, <code>term</code>, <code>nonvar</code>, <code>var</code>, <code>atomic</code>, <code>atom</code>, <code>number</code>, <code>integer</code>, <code>float</code>, <code>compound</code>, and <code>list</code>. The first four are Logtalk specific. The remaining are common Prolog types. We can also use our own types that can be either atoms or compound terms. 
</p>
<p>
The second argument documents the number of proofs (or solutions) for the specified mode. The possible values are:
</p>
<dl>
	<dt><code>zero</code></dt>
		<dd>Predicate always fails.</dd>
	<dt><code>one</code></dt>
		<dd>Predicate always succeeds once.</dd>
	<dt><code>zero_or_one</code></dt>
		<dd>Predicate either fails or succeeds.</dd>
	<dt><code>zero_or_more</code></dt>
		<dd>Predicate has zero or more solutions.</dd>
	<dt><code>one_or_more</code></dt>
		<dd>Predicate has one or more solutions.</dd>
	<dt><code>error</code></dt>
		<dd>Predicate will throw an error (see below).</dd>
</dl>
<p>
Mode declarations can also be used to document that some call modes will throw an error. For instance, regarding the <code>arg/3</code> ISO Prolog built-in predicate, we may write:
</p>
<pre>:- mode(arg(-, -, +), error).</pre> 
<p>
Note that most predicates have more than one valid mode implying several mode directives. For example, to document the possible use modes of the <code>atom_concat/3</code> ISO built-in predicate we would write:
</p>
<pre>:- mode(atom_concat(?atom, ?atom, +atom), one_or_more).
:- mode(atom_concat(+atom, +atom, -atom), zero_or_one).</pre>
<p>
Some old Prolog compilers supported some sort of mode directives to improve performance. To the best of my knowledge, there is no modern Prolog compiler supporting these kind of directive. The current version of the Logtalk compiler just parses and than discards this directive (however, see the description on <a title="Consult user manual" href="threads.html#threads_atomic_predicates">atomic predicates</a> on the <a title="Consult user manual" href="threads.html">multi-threading programming</a> section). Nevertheless, the use of mode directives is a good starting point for documenting your predicates.
</p>

<h3>Meta-predicate directive<a id="predicates_meta"></a></h3>

<p>
Some predicates may have arguments that will be called as goals or closures that will be used for constructing a call. To ensure that these calls and closures will be executed in the correct scope (i.e. in the calling context, <em>this</em>, not in the predicate definition context) we need to use the <a title="Consult reference manual" href="../refman/directives/meta_predicate1.html"><code>meta_predicate/1</code></a> directive. For example:
</p>
<pre>:- meta_predicate(findall(*, ::, *)).</pre>
<p>
The predicate arguments in this directive have the following meaning:
</p>
<dl>
	<dt><code>::</code></dt>
		<dd>Meta-argument that will be called as a goal.</dd>
	<dt><code>N</code></dt>
		<dd>Meta-argument that will be a closure used to construct a call by appending <code>N</code> arguments at the end. The value of <code>N</code> must be a positive integer.</dd>
	<dt><code>*</code></dt>
		<dd>Normal argument.</dd>
</dl>
<p>
This is similar to the declaration of meta-predicates in the ISO standard for Prolog modules except that we use the atom <code>::</code> instead of <code>:</code> to be consistent with the message sending operators. To the best of my knowledge, the use of non-negative integers to specify closures has first introduced on Quintus Prolog for providing information for the cross-reference tools.
</p>
<p>
The <code>meta_predicate/1</code> directive must precede the meta-predicate definition and any local calls to the meta-predicate in order to ensure proper compilation. In addition, as each Logtalk entity is independently compiled, this directive must be included in every object or category that contains a definition for the described predicate, even if the predicate declaration is inherited from another entity, to ensure proper compilation of meta-arguments.
</p>

<h3>Discontiguous directive<a id="predicates_discontiguous"></a></h3>

<p>
The clause of an object (or category) predicate may not be contiguous. In that case, we must declare the predicate discontiguous by using the <a title="Consult reference manual" href="../refman/directives/discontiguous1.html"><code>discontiguous/1</code></a> directive:
</p>
<pre>:- discontiguous(foo/1).</pre>
<p>
This is a directive that we should avoid using: it makes your code harder to read and it is not supported by some Prolog compilers.
</p>
<p>
As each Logtalk entity is compiled independently from other entities, this directive must be included in every object or category that contains a definition for the described predicate (even if the predicate declaration is inherited from other entity).
</p>

<h3>Dynamic directive<a id="predicates_dynamic"></a></h3>

<p>
An object (or category) predicate can be static or dynamic. By default, all object predicates are static. To declare a dynamic predicate we use the <a title="Consult reference manual" href="../refman/directives/dynamic1.html"><code>dynamic/1</code></a> directive:
</p>
<pre>:- dynamic(foo/1).</pre>
<p>
This directive may also be used to declare dynamic grammar rule non-terminals. As each Logtalk entity is compiled independently from other entities, this directive must be included in every object or category that contains a definition for the described predicate (even if the predicate declaration is inherited from other entity). If we omit the dynamic declaration then the predicate definition will be compiled to static code. Note that any static object may declare and define dynamic predicates.
</p>

<h3>Operator directive<a id="predicates_op"></a></h3>

<p>
An object (or category) predicate can be declared as an operator using the familiar <a title="Consult reference manual" href="../refman/directives/op3.html"><code>op/3</code></a> directive:
</p>
<pre>:- op(Priority, Specifier, Operator).</pre>
<p>
Operators are local to the object (or category) where they are declared. This means that, if you declare a public predicate as an operator, you cannot use operator notation when sending to an object (where the predicate is visible) the respective message (as this would imply visibility of the operator declaration in the context of the <em>sender</em> of the message). If you want to declare global operators and, at the same time, use them inside an entity, just write the corresponding directives at the top of your source file, before the entity opening directive.
</p>

<h3>Uses directive<a id="predicates_uses"></a></h3>

<p>
When a predicate makes heavy use of predicates defined on other objects, its clauses can be excessively verbose due to all the necessary message sending constructs. Consider the following example:
</p>
<pre>foo :-
    ...,
    findall(X, list::member(X, L), A),
    list::append(A, B, C),
    list::select(Y, C, R),
    ...</pre>
<p>
Logtalk provides a directive, <a title="Consult reference manual" href="../refman/directives/uses2.html"><code>uses/2</code></a>, which allows us to simplify the code above. The usage template for this directive is:
</p>
<pre>:- uses(Object, [Functor1/Arity1, Functor2/Arity2, ...]).</pre>
<p>
Rewriting the code above using this directive results in a simplified and more easily readable predicate definition:
</p>
<pre>:- uses(list,
    [append/3, member/2, select/3]).

    foo :-
        ...,
        findall(X, member(X, L), A),
        append(A, B, C),
        select(Y, C, R),
        ...</pre>
<p>
Logtalk supports an extended version of this directive that allows the declaration of predicate alias using the notation <code>Predicate::Alias</code>. For example:
</p>
<pre>:- uses(btrees, [new/1::new_btree/1]).
:- uses(queues, [new/1::new_queue/1]).</pre>
<p>
You may use this extended version for solving conflicts between predicates declared on several <code>uses/2</code> directives or just for giving new names to the predicates that will be more meaningful on their using context.
</p>
<p>
The <code>uses/2</code> directive allows simpler predicate definitions as long as there are no conflicts between the predicates declared in the directive and the predicates defined in the object (or category) containing the directive. A predicate (or its alias if defined) cannot be listed in more than one <code>uses/2</code> directive. In addition, a <code>uses/2</code> directive cannot list a predicate (or its alias if defined) which is defined in the object (or category) containing the directive. Any conflicts are reported by the Logtalk pre-processor as compilation errors.
</p>
<p>
In the current Logtalk version, the omission of the <code>Object::</code> prefix is not supported when the predicate call occurs as an argument of a user-defined meta-predicate (Logtalk specified meta-predicates and Prolog non-standard meta-predicates declared in the config files pose no problem).
</p>

<h3>Alias directive<a id="predicates_alias"></a></h3>

<p>
Logtalk allows the definition of an alternative name for an inherited or imported predicate (or for an inherited or imported grammar rule non-terminal) through the use of the <a title="Consult reference manual" href="../refman/directives/alias3.html"><code>alias/3</code></a> directive:
</p>
<pre>:- alias(Entity, Predicate, Alias).</pre>
<p>
This directive can be used in objects, protocols, or categories. The first argument, <code>Entity</code>, must be an entity referenced in the opening directive of the entity contain the <code>alias/3</code> directive. It can be an implemented protocol, an imported category, an extended prototype, an instantiated class, or a specialized class. The second and third arguments are predicate indicators (or grammar rule non-terminal indicators).
</p>
<p>
A common use for the <code>alias/3</code> directive is to give an alternative name to an inherited predicate in order to improve readability. For example:
</p>
<pre>:- object(square,
    extends(rectangle)).

    :- alias(rectangle, width/1, side/1).

    ...

:- end_object.</pre>
<p>
The directive allows both <code>width/1</code> and <code>side/1</code> to be used as messages to the object <code>square</code>. Thus, using this directive, there is no need to explicitly declare and define a "new" <code>side/1</code> predicate. Note that the <code>alias/3</code> directive does not rename a predicate, only provides an alternative, additional name; the original name continues to be available.
</p>
<p>
Another common use for this directive is to solve conflicts when two inherited predicates have the same functor and arity. We may want to call the predicate which is masked out by the Logtalk lookup algorithm (see the <a href="inheritance.html">Inheritance</a> section) or we may need to call both predicates. This is simply accomplished by using the <code>alias/3</code> directive to give alternative names to masked out or conflicting predicates. Consider the following example:
</p>
<pre>:- object(my_data_structure,
    extends(list, set)).

    :- alias(list, member/2, list_member/2).
    :- alias(set, member/2, set_member/2).

    ...

:- end_object.</pre>
<p>
Assuming that both <code>list</code> and <code>set</code> objects define a <code>member/2</code> predicate, without the <code>alias/3</code> directives, only the definition of <code>member/2</code> predicate in the object <code>list</code> would be visible on the object <code>my_data_structure</code>, as a result of the application of the Logtalk predicate lookup algorithm. By using the <code>alias/3</code> directives, all the following messages would be valid (assuming a public scope for the predicates):
</p>
<pre>| ?- my_data_structure::list_member(X, L).    % uses list member/2

| ?- my_data_structure::set_member(X, L).     % uses set member/2

| ?- my_data_structure::member(X, L).         % uses list member/2</pre>
<p>
When used this way, the <code>alias/3</code> directive provides functionality similar to programming constructs of other object-oriented languages which support multi-inheritance (the most notable example probably being the renaming of inherited features in Eiffel).
</p>
<p>
Note that the <code>alias/3</code> directive never hides a predicate which is visible on the entity containing the directive as a result of the Logtalk lookup algorithm. However, it may be used to make visible a predicate which otherwise would be masked by another predicate, as illustrated in the above example.
</p>
<p>
The <code>alias/3</code> directive may also be used to give access to an inherited predicate, which otherwise would be masked by another inherited predicate, while keeping the original name as follows:
</p>
<pre>:- object(my_data_structure,
    extends(list, set)).

    :- alias(list, member/2, list_member/2).
    :- alias(set, member/2, set_member/2).

    member(X, L) :-
        ::set_member(X, L).

    ...

:- end_object.</pre>
<p>
Thus, when sending the message <code>member/2</code> to <code>my_data_structure</code>, the predicate definition in <code>set</code> will be used instead of the one contained in <code>list</code>.
</p>

<h3>Documenting directive<a id="predicates_info"></a></h3>

<p>
A predicate can be documented with arbitrary user-defined information by using the <a title="Consult reference manual" href="../refman/directives/info2.html"><code>info/2</code></a> directive:
</p>
<pre>:- info(Functor/Arity, List).</pre>
<p>
The second argument is a list of <code>Key is Value</code> terms. See the <a href="documenting.html">Documenting Logtalk programs</a> session for details.
</p>

<h2>Defining predicates<a id="predicates_defining"></a></h2>

<h3>Object predicates<a id="predicates_objects"></a></h3>

<p>
We define object predicates as we have always defined Prolog predicates, the only difference be that we have four more control structures (the three message sending operators plus the external call operator) to play with. For example, if we wish to define an object containing common utility list predicates like <code>append/2</code> or <code>member/2</code> we could write something like:
</p>
<pre>:- object(list).

    :- public(append/3).
    :- public(member/2).

    append([], L, L).
    append([H| T], L, [H| T2]) :-
        append(T, L, T2).

    member(H, [H| _]).
    member(H, [_| T]) :-
        member(H, T).

:- end_object.</pre>
<p>
Note that, abstracting from the opening and closing object directives and the scope directives, what we have written is plain Prolog.  Calls in a predicate definition body default to the local predicates, unless we use the message sending operators or the external call operator. This enables easy conversion from Prolog code to Logtalk objects: we just need to add the necessary encapsulation and scope directives to the old code.
</p>

<h3>Category predicates<a id="predicates_categories"></a></h3>

<p>
Because a category can be imported by several different objects, dynamic private predicates must be called using the <a title="Consult reference manual" href="../refman/control/to_self1.html"><code>::/1</code></a> message sending operator. This ensures that the correct predicate definition will be used. For example, if we want to define a category implementing variables using destructive assignment we could write:
</p>
<pre>:- category(variable).

    :- public(get/2).
    :- public(set/2).

    :- private(value_/2).
    :- dynamic(value_/2).

    get(Var, Value) :-
        ::value_(Var, Value).

    set(Var, Value) :-
        ::retractall(value_(Var, _)), 
        ::asserta(value_(Var, Value).

:- end_category.</pre>
<p>
This way, each importing object will have its own definition for the <code>value_/2</code> private predicate. Furthermore, the <code>get/2</code> and <code>set/2</code> predicates will always access/update the correct definition, contained in the object receiving the messages.
</p>
<p>
A category may only contain clauses for static predicates. Nevertheless, as the example above illustrates, there are no restrictions in declaring and calling dynamic predicates from inside a category.
</p>

<h3>Meta-predicates<a id="predicates_metadef"></a></h3>

<p>
Meta-predicates may be defined inside objects (and categories) as any other predicate. A meta-predicate is declared using the <code>meta_predicate/1</code> directive as described earlier on this section. When defining a meta-predicate, the arguments in the clause heads corresponding to the meta-arguments must be variables. All meta-arguments are called in the context of the object calling the meta-predicate (either directly or through message sending).
</p>
<p>
Some meta-predicates have meta-arguments which are not goals but closures. Logtalk supports the definition of meta-predicates that are called with closures instead of goals as long as the definition uses the Logtalk built-in predicate <a title="Consult reference manual" href="../refman/methods/call1.html"><code>call/N</code></a> to call the closure with the addtional arguments. For example:
</p>
<pre>:- public(all_true/2).
:- meta_predicate(all_true(1, *)).

all_true(_, []).
all_true(Closure, [Arg| Args]) :-
    call(Closure, Arg),
    all_true(Closure, Args).</pre>
<p>
Note that the meta-predicate directive specifies that the closure will be extended with exactly one extra argument.
</p>

<h3>Definite clause grammars<a id="predicates_dcgs"></a></h3>

<p>
Definite clause grammar rules provide a convenient notation to represent the rewrite rules common of most grammars in Prolog. In Logtalk, definite clause grammar rules can be encapsulated in objects and categories. Currently, the ISO/IEC WG17 group is working on a draft specification for a definite clause grammars Prolog standard. Therefore, in the mean time, Logtalk follows the common practice of Prolog compilers supporting definite clause grammars, extending it to support calling grammar rules contained in categories and objects. A common example of a definite clause grammar is the definition of a set of rules for parsing simple arithmetic expressions:
</p>
<pre>:- object(calculator).

    :- public(parse/2).

    parse(Expression, Value) :-
        phrase(expr(Value), Expression).

    expr(Z) --&gt; term(X), "+", expr(Y), {Z is X + Y}.
    expr(Z) --&gt; term(X), "-", expr(Y), {Z is X - Y}.
    expr(X) --&gt; term(X).

    term(Z) --&gt; number(X), "*", term(Y), {Z is X * Y}.
    term(Z) --&gt; number(X), "/", term(Y), {Z is X / Y}.
    term(Z) --&gt; number(Z).

    number(C) --&gt; "+", number(C).
    number(C) --&gt; "-", number(X), {C is -X}.
    number(X) --&gt; [C], {0'0 =&lt; C, C =&lt; 0'9, X is C - 0'0}.

:- end_object. </pre>
<p>
The predicate <a title="Consult reference manual" href="../refman/methods/phrase2.html"><code>phrase/2</code></a> called in the definition of predicate <code>parse/2</code> above is a Logtalk built-in method, similar to the predicate with the same name found on most Prolog compilers that support definite clause grammars. After compiling and loading this object, we can test the grammar rules with calls such as the following one:
</p>
<pre>| ?- calculator::parse("1+2-3*4", Result).

Result = -9
yes</pre>
<p>
In most cases, the predicates resulting from the translation of the grammar rules to regular clauses are not declared. Instead, these predicates are usually called by using the built-in methods <code>phrase/2</code> and <code>phrase/3</code> as shown in the example above. When we want to send the messages <code>phrase/2</code> and <code>phrase/3</code> to <em>self</em> or to another object, the non-terminal used as first argument must be within the scope of the <em>sender</em>. For the above example, assuming that we want the predicate corresponding to the <code>expr//1</code> non-terminal to be public, the corresponding scope directive would be:
</p>
<pre>:- public(expr//1). </pre>
<p>
The <code>//</code> infix operator used above tells the Logtalk compiler that the scope directive refers to a grammar rule non-terminal, not to a predicate. The idea is that the predicate corresponding to the translation of the <code>expr//1</code> non-terminal will have a number of arguments equal to one plus the number of additional arguments necessary for processing the subjacent lists of tokens.
</p>
<p>
In the body of a grammar rule, we can call rules that are inherited from ancestor objects, imported from categories, or contained in other objects. This is accomplished by using non-terminals as messages. Using a non-terminal as a message to <em>self</em> allows us to call grammar rules in categories and ancestor objects. To call grammar rules encapsulated in other objects, we use a non-terminal as a message to those objects. Consider the following example, containing grammar rules for parsing natural language sentences:
</p>
<pre>:- object(sentence,
    imports(determiners, nouns, verbs)).

    :- public(parse/2).

    parse(List, true) :-
        phrase(sentence, List).
    parse(_, false).

    sentence --&gt; noun_phrase, verb_phrase.

    noun_phrase --&gt; ::determiner, ::noun.
    noun_phrase --&gt; ::noun.

    verb_phrase --&gt; ::verb.
    verb_phrase --&gt; ::verb, noun_phrase.

:- end_object.</pre>
<p>
The categories imported by the object would contain the necessary grammar rules for parsing determiners, nouns, and verbs. For example:
</p>
<pre>:- category(determiners).

    :- private(determiner//0).

    determiner --&gt; [the].
    determiner --&gt; [a].

:- end_category.</pre>
<p>
Along with the message sending operators (<code>::/1</code> and <code>::/2</code>), we may also use other control constructs such as <code>\+/1</code>, <code>!/0</code>, <code>;/2</code>, <code>-&gt;/2</code>, and <code>{}/1</code> in the body of a grammar. In addition, grammar rules may contain meta-calls (a variable taking the place of a non-terminal), which are translated to calls of the built-in method <code>phrase/3</code>. 
</p>
<p>
You may have noticed that Logtalk defines <code>{}/1</code> as a control construct for bypassing the compiler when compiling a clause body goal. As exemplified above, this is the same control construct that is used in grammar rules for bypassing the expansion of rule body goals when a rule is converted into a clause. Both control constructs can be combined in order to call a goal from a grammar rule body, while bypassing at the same time the Logtalk compiler. Consider the following example:
</p>
<pre>bar :-
    write('bar predicate called'), nl.


:- object(bypass).

    :- public(foo//0).

    foo --&gt; {{bar}}.

:- end_object.</pre>
<p>
After compiling and loading this code, we may try the following query:
</p>
<pre>| ?- bypass::phrase(foo, _, _).

bar predicate called
yes</pre>
<p>
This is the expected result as the expansion of the grammar rule into a clause leaves the <code>{bar}</code> goal untouched, which, in turn, is converted into the goal <code>bar</code> when the clause is compiled.
</p>
<p>
A grammar rule non-terminal may be declared as dynamic or discontiguous, as any object predicate, using the same <code><em>Functor//Arity</em></code> notation illustrated above for the scope directives. In addition, grammar rule non-terminals can be documented using the <a title="Consult reference manual" href="../refman/directives/info2.html"><code>info/2</code></a> directive, as in the following example:
</p>
<pre>:- public(sentence//0).

:- info(sentence//0, [
    comment is 'Rewrites a sentence into a noun phrase and a verb phrase.']).</pre>

<h2>Built-in object predicates (methods)<a id="predicates_methods"></a></h2>

<p>
Logtalk defines a set of built-in object predicates or methods to access message execution context, to find sets of solutions, to inspect objects and for database handling. Similar to Prolog built-in predicates, these built-in methods should not be redefined.
</p>

<h3>Execution context methods<a id="predicates_context"></a></h3>

<p>
Logtalk defines four built-in methods to access an object execution context. These methods (with the possible exception of <code>parameter/2</code>) are translated to a single unification performed at compile time with a clause head context argument. Therefore, they can be freely used without worrying about performance penalties. When called from inside a category, these methods refer to the execution context of the object importing the category.
</p>
<p>
To find the object that received the message under execution we may use the <a title="Consult reference manual" href="../refman/methods/self1.html"><code>self/1</code></a> method. We may also retrieve the object that has sent the message under execution using the <a title="Consult reference manual" href="../refman/methods/sender1.html"><code>sender/1</code></a> method.
</p>
<p>
The method <a title="Consult reference manual" href="../refman/methods/this1.html"><code>this/1</code></a> enables us to retrieve the name of the object that contains the code that is being executed instead of using the name directly. This helps to avoid breaking the code if we decide to change the object name and forget to change the name references.
</p>
<p>
Here is a short example including calls to these three object execution context methods:
</p>
<pre>:- object(test).

    :- public(test/0).

    test :-
        this(This), 
        write('Executing  a predicate definition contained in '), writeq(This), nl,
        self(Self),
        write('to answer a message received by '), writeq(Self), nl,
        sender(Sender),
        write('that was sent by '), writeq(Sender), nl, nl.

:- end_object.


:- object(descendant,
    extends(test)).

:- end_object.</pre>
<p>
After compiling and loading these two objects, we can try the following goal:
</p>
<pre>| ?- descendant::test.

Executing  a predicate definition contained in test
to answer a message received by descendant
that was sent by user
yes</pre>
<p>
Note that the goals <code>self(Self)</code>, <code>sender(Sender)</code>, and <code>this(This)</code>, being translated to unifications with the clause head context arguments at compile time, are effectively removed from the clause body. This implies that a clause such as:
</p>
<pre>predicate(Arg) :-
    self(Self),
    atom(Arg),
    ... .</pre>
<p>
is compiled with the goal <code>atom(Arg)</code> as the first condition on the clause body. As such, the use of these context execution methods do not interfere with the optimizations that some Prolog compilers perform when the first clause body condition is a call to a built-in type-test predicate or a comparison operator. 
</p>
<p>
For parametric objects, the method <a title="Consult reference manual" href="../refman/methods/parameter2.html"><code>parameter/2</code></a> enables us to retrieve current parameter values (see the session on <a href="objects.html#parametric">parametric objects</a> for a detailed description). For example:
</p>
<pre>:- object(block(_Color)).

    :- public(test/0).

    test :-
        parameter(1, Color), 
        write('Color parameter value  is '), writeq(Color), nl.

:- end_object.</pre>
<p>
After compiling and loading these two objects, we can try the following goal:
</p>
<pre>| ?- block(blue)::test.

Color parameter value is blue
yes</pre>
<p>
The method <code>parameter/2</code> is only translated to a compile time unification when used inside objects with its first argument instantiated at compile time. When the first argument is not known at compile time, or when the method is used inside categories, its call implies a call to the built-in Prolog predicate <code>arg/3</code>. Nevertheless, note that calls to <code>parameter/2</code> from inside categories are inherently problematic: a category may be implemented by several objects, both parametric (with different number of parameters) and non-parametric. Care must be taken to ensure that a parametric object importing such a category match the interpretation of its parameters used in the category.
</p>

<h3>Database methods<a id="predicates_database"></a></h3>

<p>
Logtalk provides a set of built-in methods for object database handling similar to the usual database Prolog predicates: <a title="Consult reference manual" href="../refman/methods/abolish1.html"><code>abolish/1</code></a>, <a title="Consult reference manual" href="../refman/methods/asserta1.html"><code>asserta/1</code></a>, <a title="Consult reference manual" href="../refman/methods/assertz1.html"><code>assertz/1</code></a>, <a title="Consult reference manual" href="../refman/methods/clause2.html"><code>clause/2</code></a>, <a title="Consult reference manual" href="../refman/methods/retract1.html"><code>retract/1</code></a>, and <a title="Consult reference manual" href="../refman/methods/retractall1.html"><code>retractall/1</code></a>. These methods always operate on the database of the object receiving the corresponding message.
</p>
<p>
When working with dynamic grammar rule non-terminals, you may use the built-in method <a title="Consult reference manual" href="../refman/methods/expand_term2.html"><code>expand_term/2</code></a> convert a grammar rule into a clause that can than be used with the database methods.
</p>

<h3>Meta-call methods<a id="predicates_metacalls"></a></h3>

<p>
Logtalk supports the generalizaed <a title="Consult reference manual" href="../refman/methods/call1.html"><code>call/N</code></a> predicate as a built-in. This built-in predicate must be used in the implementation of meta-predicates which work with closures instead of goals.
</p>

<h3>All solutions methods<a id="predicates_solutions"></a></h3>

<p>
The usual all solutions meta-predicates are pre-defined methods in Logtalk: <a title="Consult reference manual" href="../refman/methods/bagof3.html"><code>bagof/3</code></a>, <a title="Consult reference manual" href="../refman/methods/findall3.html"><code>findall/3</code></a>, and <a title="Consult reference manual" href="../refman/methods/setof3.html"><code>setof/3</code></a>. There is also a <a title="Consult reference manual" href="../refman/methods/forall2.html"><code>forall/2</code></a> method that implements generate and test loops.
</p>

<h3>Reflection methods<a id="predicates_reflection"></a></h3>

<p>
Logtalk provides two built-in methods for inspecting object predicates: <a title="Consult reference manual" href="../refman/methods/predicate_property2.html"><code>predicate_property/2</code></a>, which returns predicate properties and <a title="Consult reference manual" href="../refman/methods/current_predicate1.html"><code>current_predicate/1</code></a>, which enables us to query about predicate definitions. See below for a more detailed description of both methods.
</p>

<h3>Definite clause grammar parsing methods<a id="predicates_parsing"></a></h3>

<p>
Logtalk supports two definite clause grammar parsing built-in methods, <a title="Consult reference manual" href="../refman/methods/phrase2.html"><code>phrase/2</code></a> and <a title="Consult reference manual" href="../refman/methods/phrase3.html"><code>phrase/3</code></a>, with definitions similar to the predicates with the same name found on most Prolog compilers that support definite clause grammars.
</p>

<h3>Term expansion methods<a id="predicates_expanding"></a></h3>

<p>
Logtalk supports a <a title="Consult reference manual" href="../refman/methods/expand_term2.html"><code>expand_term/2</code></a> built-in method for expanding a term into another. This method is mostly used to translate grammar rules into Prolog clauses. It can be customized, e.g. for bypassing the default Logtalk grammar rule translator, by defining clause for the predicate <a title="Consult reference manual" href="../refman/methods/term_expansion2.html"><code>term_expansion/2</code></a>.
</p>

<h2>Predicate properties<a id="predicates_properties"></a></h2>

<p>
We can find the properties of visible predicates by calling the <a title="Consult reference manual" href="../refman/methods/predicate_property2.html"><code>predicate_property/2</code></a> built-in method. For example:
</p>
<pre>| ?- bar::predicate_property(foo(_), Property).</pre>
<p>
Note that this method respects the predicate's scope declarations. For instance, the above call will only return properties for public predicates.
</p>
<p>
An object's set of visible predicates is the union of all the predicates declared for the object with all the built-in methods and all the Logtalk and Prolog built-in predicates.
</p>
<p>
Possible predicate properties values are:
</p>
<ul>
	<li><code>public</code>, <code>protected</code>, <code>private</code></li>
	<li><code>static</code>, <code>dynamic</code></li>
	<li><code>built_in</code></li>
	<li><code>meta_predicate(Mode)</code></li>
	<li><code>declared_in(Entity)</code></li>
	<li><code>defined_in(Entity)</code></li>
	<li><code>non_terminal(NonTerminal//Arity)</code></li>
	<li><code>alias(Predicate)</code></li>
	<li><code>atomic</code></li>
</ul>
<p>
The properties <code>declared_in/1</code> and <code>defined_in/1</code> do not apply to built-in methods and Logtalk or Prolog built-in predicates. Note that if a predicate is declared in a category imported by the object, it will be the category name &mdash; not the object name &mdash; that will be returned by the property <code>declared_in/1</code>. The same goes for protocol declared predicates.
</p>
<p>
The property <code>non_terminal/1</code> only applies to predicates that result from the compilation of grammar rule non-terminals. 
</p>
<p>
The property <code>alias/1</code> is returned for predicates that are an alias to other predicate (which is returned in the property argument).
</p>
<p>
The property <code>atomic</code> is returned for predicates that are declared atomic when doing multi-threading programming.
</p>


<h2>Finding declared predicates<a id="predicates_finding"></a></h2>

<p>
We can find, by backtracking, all visible user predicates by calling the <a title="Consult reference manual" href="../refman/methods/current_predicate1.html"><code>current_predicate/1</code></a> built-in method. This method respects the predicate's scope declarations. For instance, the following call:
</p>
<pre>| ?- some_object::current_predicate(Functor/Arity).</pre>
<p>
will only return user predicates that are declared public. The predicate property <code>non_terminal/1</code> may be used to retrieve all grammar rule non-terminals declared for an object. For example:
</p>
<pre>current_non_terminal(Object, NonTerminal//Args) :-
    Object::current_predicate(Functor/Arity),
    functor(Predicate, Functor, Arity),
    Object::predicate_property(Predicate, non_terminal(NonTerminal//Args)).</pre>
<p>
Usually, the non-terminal and the corresponding predicate share the same functor but users should not rely on this always being true.
</p>

<h2>Calling Prolog built-in predicates<a id="predicates_prolog"></a></h2>

<p>
In predicate definitions, predicate calls which are not prefixed with a message sending operator (either <code>::</code> or <code>^^</code>), are compiled to either calls to local predicates or as calls to Logtalk/Prolog built-in predicates. A predicate call is compiled as a call to a local predicate if the object (or category) contains a definition for the called predicate or a dynamic declaration for it. When the object (or category) does not contain either a definition of the called predicate or a corresponding dynamic declaration, Logtalk tests if the call corresponds to a Logtalk or Prolog built-in predicate. Calling a predicate which is neither a local predicate nor a Logtalk/Prolog built-in predicate results in a compile time warning. This means that, in the following example:
</p>
<pre>foo :-
    ...,
    write(bar),
    ...</pre>
<p>
the call to the predicate <code>write/1</code> will be compiled as a call to the corresponding Prolog built-in predicate unless the object (or category) encapsulating the above definition also contains a predicate named <code>write/1</code> or a dynamic declaration for the predicate.
</p>
<p>
When calling non-standard Prolog built-in predicates, you may run into portability problems when trying your applications with other Prolog compilers which might not have the same set of built-in predicates. You may use the Logtalk compiler flag <a title="Consult user manual" href="running.html#options"><code>portability/1</code></a> to help you check for problematic calls in your code.
</p>

<h3>Calling Prolog non-standard meta-predicates<a id="predicates_prolog_meta"></a></h3>

<p>
Compiling calls to non-standard, Prolog built-in meta-predicates can be tricky because there is no standard way of checking if a built-in predicate is also a meta-predicate and finding out which are its meta-arguments. Moreover, the meta-arguments of a meta-predicate may be closures instead of goals. Thus, it is not allways possible for the Logtalk compiler to infer in a reliable way how to properly compile a call to a non-standard Prolog built-in meta-predicate. The solution is to explicitly declare these meta-predicates in the corresponding Prolog configuration file using the predicate <code>'$lgt_pl_meta-predicate'/1</code>. For example:
</p>
<pre>'$lgt_pl_meta_predicate'(call_with_depth_limit(::, *, *)).</pre>

<div class="footer">
	<div class="copyright">
		<span>Copyright &copy; <a href="mailto:pmoura@logtalk.org">Paulo Moura</a> &mdash; <a href="http://logtalk.org">Logtalk.org</a></span><br/>	
		<span>Last updated on: December 7, 2006</span>
	</div>
	<div class="navbottom">
		<span><a href="categories.html">previous</a> | <a href="../glossary.html">glossary</a> | <a href="inheritance.html">next</a></span><br/>
		<span><a href="http://validator.w3.org/check/referer">XHTML</a> + <a href="http://jigsaw.w3.org/css-validator/check/referer">CSS</a></span>
	</div>
</div>

</body>

</html>
