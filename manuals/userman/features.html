<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">

<head>
	<meta http-equiv="content-type" content="application/xml+xhtml; charset=utf-8" />
	<title>Logtalk user manual: logtalk features</title>
	<link rel="stylesheet" href="../screen.css" type="text/css" media="screen"/>
	<link rel="stylesheet" href="../print.css" type="text/css" media="print"/>
</head>

<body>

<div class="top-left">Logtalk user manual</div> 
<div class="top-right">Logtalk features</div>
<div class="bottom-left"><span class="page"/></div> 
<div class="bottom-right"><span class="page"/></div>
<div class="navtop"><a href="../index.html">contents</a> &gt; <a href="index.html">user manual</a></div>

<h1>Logtalk features</h1>

<p>
Some years ago, I decided that the best way to learn object-oriented programming was to build my own object-oriented language. Prolog always being my favorite language, I chose to extend it with object-oriented capabilities. Eventually this work has lead to the Logtalk system. The first public release of Logtalk 1.x occurred in February of 1995. Based on feedback by users and on the author subsequent work, the second major version went public in July of 1998.
</p>
<p>
Although this version of Logtalk shares many ideas and goals with previous 1.x versions, programs written for one version are not compatible with the other (however, conversion from previous versions can easily be accomplished in most cases). This is a consequence of the desire to have a more friendly system, with a very smooth learning curve, bringing Logtalk programming closer to traditional Prolog programming. There are, of course, also other important changes, that result in a more powerful and funnier system. Logtalk 2.x development provides the following features:
</p>

<h2>Integration of logic and object-oriented programming<a id="logic"></a></h2>

<blockquote>
<p>
Logtalk tries to bring together the main advantages of these two programming paradigms. On one hand, the object orientation allows us to work with the same set of entities in the successive  phases of application development, giving us a way of organizing and encapsulating the knowledge of each entity within a given domain. On the other hand, logic programming allows us to represent, in a declarative way, the knowledge we have of each entity. Together, these two advantages allow us to minimize the distance between an application and its problem domain, turning the writing and maintenance of programming easier and more productive.
</p>
<p>
In a more pragmatically view, Logtalk objects provide Prolog with the possibility of defining several namespaces, instead of the traditional Prolog single database, addressing some of the needs of large software projects.
</p>
</blockquote>

<h2>Integration of event-driven and object-oriented programming<a id="events"></a></h2>

<blockquote>
<p>
Event-driven programming enables the building of reactive systems, where computing which takes place at each moment is a result of the observation of occurring events. This integration complements object-oriented programming, in which each computing is initiated by the explicit sending of a message to an object. The user dynamically defines what events are to be observed and establishes monitors for these events. This is specially useful when representing relationships between objects that imply constraints in the state of participating objects <a href="../bibliography.html#Rumbaugh87">[Rumbaugh 87</a>, <a href="../bibliography.html#Rumbaugh88">Rumbaugh 88</a>, <a href="../bibliography.html#Fornarino89">Fornarino 89</a>, <a href="../bibliography.html#Razek92">Razek 92]</a>. Other common uses are reflective applications like code debugging or profiling <a href="../bibliography.html#Maes87">[Maes 87]</a>.
</p>
</blockquote>

<h2>Support for component-based programming<a id="categories"></a></h2>

<blockquote>
<p>
Predicates can be encapsulated inside <em>categories</em> which can be imported by any object. A category is a first-class encapsulation entity, at the same level as objects and protocols, which can be used as a component when building new objects. Categories allows for code reuse between non-related objects, independent of hierarchy relations, in the same vein as protocols allow for interface reuse.
</p>
</blockquote>

<h2>Support for both prototype and class-based systems<a id="both"></a></h2>

<blockquote>
<p>
Almost any (if not all) object-oriented languages available today are either class-based or prototype-based <a href="../bibliography.html#Lieberman86">[Lieberman 86]</a>, with a strong predominance of class-based languages. Logtalk provides support for both hierarchy types. That is, we can have both prototype and class hierarchies in the same application. Prototypes solve a problem of class-based systems where we sometimes have to define a class that will have only one instance in order to reuse a piece of code. Classes solves a dual problem in prototype based systems where it is not possible to encapsulate some code to be reused by other objects but not by the encapsulating object. Stand-alone objects, that is, objects that do not belong to any hierarchy, are a convenient solution to encapsulate code that will be reused by several unrelated objects.
</p>
</blockquote>

<h2>Support for multiple object hierarchies<a id="multiple"></a></h2>

<blockquote>
<p>
Languages like Smalltalk-80 <a href="../bibliography.html#Goldberg83">[Goldberg 83]</a>, Objective-C <a href="../bibliography.html#Cox86">[Cox 86]</a> and Java <a href="../bibliography.html#Joy00">[Joy et al. 00]</a> define a single hierarchy rooted in a class usually named <code>Object</code>. This makes it easy to ensure that all objects share a common behavior but also tends to result in lengthy hierarchies where it is difficult to express objects which represent exceptions to default behavior. In Logtalk we can have multiple, independent, object hierarchies. Some of them can be prototype-based while others can be class-based. Furthermore, stand-alone objects provide a simple way to encapsulate utility predicates that do not need or fit in an object hierarchy.
</p>
</blockquote>

<h2>Separation between interface and implementation<a id="interface"></a></h2>

<blockquote>
<p>
This is an expected (should we say standard ?) feature of almost any modern programming language. Logtalk provides support for separating interface from implementation in a flexible way: protocol directives can be contained in an object, a category or a protocol (first-order entities in Logtalk) or can be spread in both objects, categories and protocols.
</p>
</blockquote>

<h2>Private, protected and public inheritance<a id="inheritance"></a></h2>

<blockquote>
<p>
Logtalk supports private, protected and public inheritance in a similar way to C++ <a href="../bibliography.html#Stroustrup86">[Stroustrup 86]</a>, enabling us to restrict the scope of inherited, imported or implemented predicates (by default inheritance is public).
</p>
</blockquote>

<h2>Private, protected and public object predicates<a id="predicates"></a></h2>

<blockquote>
<p>
Logtalk supports data hiding by implementing private, protected and public object predicates in a way similar to C++ <a href="../bibliography.html#Stroustrup86">[Stroustrup 86]</a>. Private predicates can only be called from the container object. Protected predicates can be called by the container object or by the container descendants. Public predicates can be called from any object.
</p>
</blockquote>

<h2>Parametric objects<a id="parametric"></a></h2>

<blockquote>
<p>
Object names can be compound terms (instead of atoms), providing a way to parameterize object predicates. Parametric objects are implemented in a similar way to <code>L&amp;O</code> <a href="../bibliography.html#McCabe92">[McCabe 92]</a>, <code>OL(P)</code> <a href="../bibliography.html#Fromherz93">[Fromherz 93]</a> or <code>SICStus Objects</code> <a href="../bibliography.html#SICStus95">[SICStus 95]</a>. However, access to parameter values is done via a built-in method instead of making the parameters scope global over the whole object.
</p>
</blockquote>

<h2>Smooth learning curve<a id="learning"></a></h2>

<blockquote>
<p>
Logtalk has a smooth learning curve, by adopting standard Prolog syntax (using a preprocessor) and by enabling an incremental learning and use of most of its features.
</p>
</blockquote>

<h2>Compatibility with most Prologs and the ISO standard<a id="compatibility"></a></h2>

<blockquote>
<p>
The Logtalk system has been designed to be compatible with most Prolog compilers and, in particular, with the ISO Prolog standard <a href="../bibliography.html#ISO95">[ISO 95]</a>. It runs in almost any computer system with a modern Prolog compiler.
</p>
</blockquote>

<h2>Performance<a id="performance"></a></h2>

<blockquote>
<p>
The current Logtalk implementation works as a pre-processor: Logtalk source files are first compiled to Prolog source files, which are then compiled by the chosen Prolog compiler. Therefore, Logtalk performance necessarily depends on the back-end Prolog compiler. The Logtalk pre-processor respects the programmers choices when writing efficient code that takes advantage of tail recursion and first-argument indexing.
</p>
<p>
As an object-oriented language, Logtalk uses dynamic binding for matching messages and methods. Furthermore, Logtalk entities (objects, protocols, and categories) are independently compiled, allowing for a very flexible programming development. Entities can be edited, compiled, and loaded at runtime, without necessarily implying recompilation of all related entities.
</p>
<p>
The Logtalk runtime engine implements caching of method lookups (including messages to <em>self</em> and <em>super</em> calls), ensuring a performance level close to what could be achieved with static binding implementations.
</p>
</blockquote>

<div class="footer">
	<div class="navbottom">
		<span class="floatleft"><a href="features.pdf">PDF version</a></span>
		<span class="floatright"><a href="index.html">previous</a> | <a href="../glossary.html">glossary</a> | <a href="messages.html">next</a></span>
	</div>
	<div class="copyright">Copyright &copy; <a href="mailto:pmoura@logtalk.org">Paulo Moura</a> &mdash; <a href="http://logtalk.org">Logtalk.org</a></div>
	<div class="footnote">
		<span class="floatleft"><a href="http://validator.w3.org/check/referer">XHTML</a> + <a href="http://jigsaw.w3.org/css-validator/check/referer">CSS</a></span>
		<span class="floatright">Last updated on: November 16, 2005</span>
	</div>
</div>

</body>
</html>
