<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">

<head>
	<meta http-equiv="content-type" content="application/xml+xhtml; charset=utf-8" />
	<title>Logtalk user manual: writing, running, and debugging programs</title>
	<link rel="stylesheet" href="../screen.css" type="text/css" media="screen"/>
	<link rel="stylesheet" href="../print.css" type="text/css" media="print"/>
</head>

<body>

<div class="top-left">Logtalk user manual</div> 
<div class="top-right">Writing, running, and debugging programs</div>
<div class="bottom-left"><span class="page"/></div> 
<div class="bottom-right"><span class="page"/></div>
<div class="navtop"><a href="../index.html">Contents</a> &gt; <a href="index.html">User Manual</a> &gt; Programming</div>

<h1 id="programming_programming">Writing, running, and debugging programs</h1>


<h2 id="programming_writing">Writing programs</h2>

<p>
For a successful programming in Logtalk, you need a good working knowledge of Prolog and an understanding of the principles of object-oriented programming. All guidelines for writing good Prolog code apply as well to Logtalk programming. To those guidelines, you should add the basics of good object-oriented design.
</p>
<p>
One of the advantages of a system like Logtalk is that it enable us to use the currently available object-oriented methodologies, tools, and metrics <a href="../bibliography.html#Champaux92">[Champaux 92]</a> in Prolog programming. That said, writing programs in Logtalk is similar to writing programs in Prolog: we define new predicates describing what is true about our domain objects, about our problem solution. We encapsulate our predicate directives and definitions inside new objects, categories and protocols that we create by hand with a text editor or by using the Logtalk built-in predicates. Some of the information collected during the analysis and design phases can be integrated in the objects, categories and protocols that we define by using the available entity and predicate documenting directives.
</p>

<h3 id="programming_source_files">Source files</h3>

<p>
Logtalk source files may contain any number of objects, categories, protocols, and plain Prolog code. If you prefer to define each entity in its own source file, then it is recommended that the source file be named after the entity identifier. For parametric objects, the identifier arity can be appended to the identifier functor. By default, all Logtalk source files use the extension <code>.lgt</code> but this is optional and can be set in the configuration files. Intermediate Prolog source files (generated by the Logtalk compiler) have, by default, a <code>.pl</code> extension. Again, this can be set to match the needs of a particular Prolog compiler in the corresponding configuration file. For example, we may define an object named <code>vehicle</code> and save it in a <code>vehicle.lgt</code> source file that will be compiled to a <code>vehicle.pl</code> Prolog file. If we have a <code>sort(_)</code> parametric object we can save it on a <code>sort_1.lgt</code> source file that will be compiled to a <code>sort_1.pl</code> Prolog file. This name scheme helps avoid file name conflicts (remember that all Logtalk entities share the same name space).
</p>
<p>
Logtalk source files may contain arbitrary Prolog directives and clauses interleaved with Logtalk entity definitions. These directives and clauses are  be copied unchanged to the corresponding Prolog output file. This feature is included to help the integration of Logtalk with Prolog extensions such as, for example, constraint programming extensions. The following Prolog directives are processed when read (thus affecting the compilation of the source code that follows): <code>ensure_loaded/1</code>, <code>op/3</code>, and <code>set_prolog_flag/2</code>. The <code>initialization/1</code> directive may be used for defining an initialization goal to be executed when loading a source file. 
</p>
<p>
The text encoding used in a source file may be declared using the <a title="Consult reference manual" href="../refman/directives/encoding1.html"><code>encoding/1</code></a> directive when running Logtalk with some back-end Prolog compilers that support multiple encodings (check the <code>encoding_directive</code> flag in the configuration file of your Prolog compiler). The encoding used (and, in the case of a Unicode encoding, any BOM present) in a source file will be used for the generated Prolog and XML files. Logtalk uses the encoding names specified by <a title="" href="http://www.iana.org/assignments/character-sets">IANA</a> (in those cases where a preferred MIME name alias is specified, the alias is used instead).
</p>

<h3 id="programming_portability">Portable programs</h3>

<p>
Logtalk is compatible with almost all modern Prolog compilers. However, this does not necessarily imply that your Logtalk programs will have the same level of portability. If possible, you should only use in your programs Logtalk built-in predicates and ISO Prolog specified built-in predicates and arithmetic functions. If you need to use built-in predicates (or built-in arithmetic functions) that may not be available in other Prolog compilers, you should try to encapsulate the non-portable code in a small number of objects and provide a portable <strong>interface</strong> for that code through the use of Logtalk protocols. An example will be code that access operating-system specific features. The Logtalk compiler can warn you of the use of non-ISO specified built-in predicates and arithmetic functions by using the <code>portability/1</code> compiler flag.
</p>

<h3 id="programming_cc">Conditional compilation</h3>

<p>
Logtalk supports conditional compilation within source files using the <a title="Consult reference manual" href="../refman/directives/if1.html"><code>if/1</code></a>, <a title="Consult reference manual" href="../refman/directives/elif1.html"><code>elif/1</code></a>, <a title="Consult reference manual" href="../refman/directives/else0.html"><code>else/0</code></a>, and <a title="Consult reference manual" href="../refman/directives/endif0.html"><code>endif/0</code></a> directives. This support is similar to the support found in some Prolog compilers such as ECLiPSe, SWI-Prolog, or YAP.
</p>

<h3 id="programming_errors">Avoiding common errors</h3>

<p>
Try to write objects and protocol documentation <strong>before</strong> writing any other code; if you are having trouble documenting a predicate perhaps we need to go back to the design stage.
</p>
<p>
Try to avoid lengthy hierarchies. Besides performance penalties, composition is often a better choice over inheritance for defining new objects (Logtalk supports component-based programming through the use of categories). In addition, prototype-based hierarchies are conceptually simpler and more efficient than class-based hierarchies.
</p>
<p>
Dynamic predicates or dynamic entities are sometimes needed, but we should always try to minimize the use of non-logical features like destructive assignment (asserts and retracts).
</p>
<p>
Since each Logtalk entity is independently compiled, if an object inherits a dynamic or a meta-predicate predicate, then we must repeat the respective directives in order to ensure a correct compilation. 
</p>
<p>
In general, Logtalk does not verify if a user predicate call/return arguments comply with the declared modes. On the other hand, Logtalk built-in predicates, built-in methods, and message sending control structures are carefully checked for calling mode errors.
</p>
<p>
Logtalk error handling strongly depends on the ISO compliance of the chosen Prolog compiler. For instance, the error terms that are generated by some Logtalk built-in predicates assume that the Prolog built-in predicates behave as defined in the ISO standard regarding error conditions. In particular, if your Prolog compiler does not support a <code>read_term/3</code> built-in predicate compliant with the ISO Prolog Standard definition, then the current version of the Logtalk compiler may not be able to detect misspell variables in your source code.
</p>

<h3 id="programming_style">Coding style guidelines</h3>

<p>
It is suggested that all code between an entity opening and closing directives be indented by one tab stop. When defining entity code, both directives and predicates, Prolog coding style guidelines may be applied. All Logtalk source files, examples, and standard library entities use four-space tabs for laying out code. Closed related entities should be defined in the same source file. Entities that might be useful in different contexts (such as library entities) are best defined in their own source files.
</p>


<h2 id="programming_session">Running a Logtalk session</h2>

<p>
We run Logtalk inside a normal Prolog session, after loading the necessary files. Logtalk extends but does not modify your Prolog compiler. We can freely mix Prolog queries with the sending of messages and our programs can be made of both normal Prolog clauses and object definitions.
</p>

<h3 id="programming_starting">Starting Logtalk</h3>

<p>
Depending on your Logtalk installation, you may use a script or a shortcut to start Logtalk with your chosen Prolog compiler. On POSIX operating systems, the scripts should be available from the command-line; scripts are named upon the used Prolog compilers. On Windows, the shortcuts should be available from the Start Menu. If no scripts or shortcuts are available for your installation, operating-system, or Prolog compiler, you can always start a Logtalk session by performing the following steps:
</p>
<ol>
	<li>Start your Prolog compiler.</li>
	<li>Load the appropriate configuration file for your compiler. Configuration files for most common Prolog compilers can be found in the <code>configs</code> subdirectory.</li>
	<li>Load the Logtalk compiler/runtime files contained in the <code>compiler</code> subdirectory.</li>
	<li>Load the library paths configuration file corresponding to your Logtalk installation contained in the <code>libpaths</code> subdirectory.</li>
</ol>
<p>
Note that the configuration files, compiler/runtime files, and library paths file are Prolog source files. The predicate called to load (and compile) them depends on your Prolog compiler. In case of doubt, consult your Prolog compiler reference manual or take a look at the definition of the predicate <code>'$lgt_load_prolog_code'/3</code> in the corresponding configuration file.
</p>
<p>
Most Prolog compilers support automatic loading of an initialization file, which can include the necessary directives to load both the Prolog configuration file and the Logtalk compiler. This feature, when available, allows automatic loading of Logtalk when you start your Prolog compiler.
</p>

<h3 id="programming_compiling">Compiling and loading your programs</h3>

<p>
Your programs will be made of source files containing your objects, protocols, and categories. After changing the Prolog working directory to the one containing your files, you can compile them to disk by calling the Logtalk built-in predicate  
<a title="Consult reference manual" href="../refman/builtins/logtalk_compile1.html"><code>logtalk_compile/1</code></a>:
</p>
<pre>| ?- logtalk_compile([source_file1, source_file2, ...]).</pre>
<p>
This predicate runs the compiler on each argument file and, if no fatal errors are found, outputs Prolog source files that can then be consulted or compiled in the usual way by your Prolog compiler.
</p>
<p>
To compile to disk and also load into memory the source files we can use the Logtalk built-in predicate <a title="Consult reference manual" href="../refman/builtins/logtalk_load1.html"><code>logtalk_load/1</code></a>:
</p>
<pre>| ?- logtalk_load([source_file1, source_file2, ...]).</pre>
<p>
This predicate works in the same way of the predicate <code>logtalk_compile/1</code> but also loads the compiled files to memory. 
</p>
<p>
Both predicates expect a source name name or a list of source name names as an argument. The Logtalk source file name extension, as defined in the configuration file, must be omitted.
</p>
<p>
If you have more than a few source files then you may want to use a loader helper file containing the calls to the <code>logtalk_load/1-2</code> predicates. Consulting or compiling the loader file will then compile and load all your Logtalk entities into memory (see below for details).
</p>
<p>
With most Prolog back-end compilers, you can use the shorthand <code>{File}</code> for <code>logtalk_load(File)</code>. The use this shorthand should be restricted to the Logtak/Prolog top-level; do not use it from within source files.
</p>

<h3 id="programming_loaders">Loader utility files</h3>

<p>
Most examples directories contain a Logtalk utility file that can be used to load all included source files. These loader utility files are usually named <code>loader.lgt</code> or contain the word "loader" in their name. Loader files are compiled and loaded like any ordinary Logtalk source file. For an example loader file named <code>loader.lgt</code> we would type:
</p>
<pre>| ?- logtalk_load(loader).</pre>
<p>
Usually these files contain a call to the Logtalk built-in predicates <a title="Consult reference manual" href="../refman/builtins/set_logtalk_flag2.html"><code>set_logtalk_flag/2</code></a> (e.g. for setting <em>project-specific</em> flag values) and <a title="Consult reference manual" href="../refman/builtins/logtalk_load1.html"><code>logtalk_load/1</code></a> or <a title="Consult reference manual" href="../refman/builtins/logtalk_load2.html"><code>logtalk_load/2</code></a> (for loading project files), wrapped inside an <code>initialization/1</code> directive. For instance, if your code is split in three Logtalk source files named <code>source1.lgt</code>, <code>source2.lgt</code>, and <code>source3.lgt</code>, then the contents of your loader file could be:
</p>
<pre>:- initialization((
	set_logtalk_flag(events, allow),              % set project-specific flags
    logtalk_load([source1, source2, source3])  % load the project source files
    )).</pre>
<p>
Another example of directives that are often used in a loader file would be <code>op/3</code> directives declaring global operators needed by your application. Loader files are also often used for setting source file-specific compiler options (this is useful even when you only have a single source file if you always load it with using the same set of compiler options). For example:
</p>
<pre>:- initialization((
	set_logtalk_flag(underscore_variables, dont_care),
	set_logtalk_flag(xmlspec, xsd),
    logtalk_load(
        [source1, source2, source3],
        [portability(warning)]),               % source file-specific flags
    logtalk_load(
        [source4, source5],
        [portability(silent)])                 % source file-specific flags
    )).</pre>
<p>
To take the best advantage of loader files, assert a clause to the dynamic predicate <code>logtalk_library_path/2</code> for the directory containing your source files, as explained in the next section.
</p>
<p>
A common mistake is to try to set compiler options using <code>logtalk_load/2</code> with a loader file. For example, by writing:
</p>
<pre>| ?- logtalk_load(loader, [xmlspec(xsd), xslfile('lgtxhtml.xsl')]).</pre>
<p>
This will not work as you might expect as the compiler options will only be used in the compilation of the <code>loader.lgt</code> file itself and will not affect the compilation of files loaded through the <code>initialization/1</code> directive contained on the loader file.	
</p>

<h3 id="programming_libraries">Libraries of source files</h3>

<p>
Logtalk defines a <em>library</em> simply as a directory containing source files. Library locations can be specified by defining or asserting clauses for the dynamic and multifile predicate <a title="Consult reference manual" href="../refman/builtins/logtalk_library_path2.html"><code>logtalk_library_path/2</code></a>. For example:
</p>
<pre>| ?- assertz(logtalk_library_path(shapes, '$LOGTALKUSER/examples/shapes/')). </pre>
<p>
The first argument of the predicate is used as an alias for the path on the second argument. Library aliases may also be used on the second argument. For example:
</p>
<pre>| ?- assertz(logtalk_library_path(lgtuser, '$LOGTALKUSER/')),
     assertz(logtalk_library_path(examples, lgtuser('examples/'))),
     assertz(logtalk_library_path(viewpoints, examples('viewpoints/'))).</pre>
<p>
This allows us to load a library source file without the need to first change the current working directory to the library directory and then back to the original directory. For example, in order to load a <code>loader.lgt</code> file, contained in a library named <code>shapes</code>, we just need to type:
</p>
<pre>| ?- logtalk_load(viewpoints(loader)). </pre>
<p>
The best way to take advantage of this feature is to load at startup a source file containing an <code>initialization/1</code> directive which asserts all the <code>logtalk_library_path/2</code> clauses needed for all available libraries. This allows us to load library source files or entire libraries without worrying about libraries paths, improving code portability. The directory paths on the second argument <strong>must</strong> always end with the path directory separator character. Most back-end Prolog compilers allows the use of environment variables in the second argument of the <code>logtalk_library_path/2</code> predicate. Use of POSIX relative paths (e.g. <code>'../'</code> or <code>'./'</code>) for top-level library directories (e.g. <code>lgtuser</code> in the example above) is not advised as different back-end Prolog compilers may start with different initial working directories, which may result in portability problems of your loader files.
</p>
<p>
Unfortunately, a few Prolog compilers do not support the <code>&lt;library&gt;(&lt;source file&gt;)</code> notation. In this case, you will need to set the working directory to be the one that contains the source file in order to load it. The library notation provides functionality similar to the <code>file_search_path/2</code> mechanism introduced by Quintus Prolog and later adopted by some other Prolog compilers.
</p>

<h3 id="programming_flags">Compiler flags</h3>

<p>
The <a title="Consult reference manual" href="../refman/builtins/logtalk_load1.html"><code>logtalk_load/1</code></a> and <a title="Consult reference manual" href="../refman/builtins/logtalk_compile1.html"><code>logtalk_compile/1</code></a> always use the current set of default compiler flags as specified in the Logtalk configuration files or changed for the current session using the built-in predicate <a title="Consult reference manual" href="../refman/builtins/set_logtalk_flag2.html"><code>set_logtalk_flag/2</code></a>. Although the default flag values cover the usual cases, you may want to use a different set of flag values while compiling or loading some of your Logtalk source files. This can be accomplished by using the <a title="Consult reference manual" href="../refman/builtins/logtalk_load2.html"><code>logtalk_load/2</code></a> or the <a title="Consult reference manual" href="../refman/builtins/logtalk_compile2.html"><code>logtalk_compile/2</code></a> built-in predicates. These two predicates accept a list of flag values affecting how a Logtalk source file is compiled and loaded:
</p>
<pre>| ?- logtalk_compile(Files, Flags).</pre>
<p>
or:
</p>
<pre>| ?- logtalk_load(Files, Flags).</pre>
<p>
In fact, the <code>logtalk_load/1</code> and <code>logtalk_compile/1</code> predicates are just shortcuts to the extended versions called with the default compiler flag values.
</p>
<p>
We may also change the default flag values from the ones loaded from the config file by using the <a title="Consult reference manual" href="../refman/builtins/set_logtalk_flag2.html"><code>set_logtalk_flag/2</code></a> built-in predicate. For example:
</p>
<pre>| ?- set_logtalk_flag(xmldocs, off).</pre>
<p>
The current default flags values can be enumerated using the <a title="Consult reference manual" href="../refman/builtins/current_logtalk_flag2.html"><code>current_logtalk_flag/2</code></a> built-in predicate:
</p>
<pre>| ?- current_logtalk_flag(xmldocs, Value).

Value = off
yes</pre>
<p>
Logtalk also implements a <a title="Consult reference manual" href="../refman/directives/set_logtalk_flag2.html"><code>set_logtalk_flag/2</code></a> directive, which can be used to set flags within a source file. For example, assuming a source file defining several entities, you may want to use different settings for compiling each entity. This can be easily accomplished by preceding each entity with the necessary <code>set_logtalk_flag/2</code> directives. Note that the scope of this directive is local to the source file containing it.
</p>

<h4>Lint flags</h4>

	<dl>
		<dt><code>unknown(Option)</code></dt>
			<dd>Controls the unknown entity warnings, resulting from loading an entity that references some other entity that is not currently loaded. Possible option values are <code>warning</code> (the usual default) and <code>silent</code>. Note that these warnings are not always avoidable, specially when using reflective designs of class-based hierarchies.</dd>
	</dl>
	<dl>
		<dt><code>misspelt(Option)</code></dt>
			<dd>Controls the misspelt predicate call warnings. A misspelt call is a call to a predicate which is not defined in the object or category containing the call, is not declared as dynamic, and is not a Logtalk/Prolog built-in predicate. Possible option values are <code>error</code>, <code>warning</code> (the usual default), and <code>silent</code> (not recommended).</dd>
	</dl>
	<dl>
		<dt><code>lgtredef(Option)</code></dt>
			<dd>Controls the Logtalk built-in predicate redefinition warnings. Possible option values are <code>warning</code> (the usual default) and <code>silent</code>. These warnings are almost always programming errors.</dd>
	</dl>
	<dl>
		<dt><code>plredef(Option)</code></dt>
			<dd>Controls the Prolog built-in predicate redefinition warnings. Possible option values are <code>warning</code> (can be very verbose if your code redefines a lot of Prolog built-in predicates) and <code>silent</code> (the usual default). When running a Logtalk application on several Prolog compilers, is possible to get different sets of warnings due to different sets of built-in predicates implemented by each Prolog compiler.</dd>
	</dl>
	<dl>
		<dt><code>portability(Option)</code></dt>
			<dd>Controls the non-ISO specified built-in predicate and non-ISO specified built-in arithmetic function calls warnings. Possible option values are <code>warning</code> and <code>silent</code> (the usual default).</dd>
	</dl>
	<dl>
		<dt><code>singletons(Option)</code></dt>
			<dd>Controls the singleton variable warnings. Possible option values are <code>warning</code> (the usual default) and <code>silent</code> (not recommended).</dd>
	</dl>
	<dl>
		<dt><code>underscore_variables(Option)</code></dt>
			<dd>Controls the interpretation of variables that start with an underscore (excluding the anonymous variable) that occur once in a term as either don't care variables or singleton variables. Possible option values are <code>dont_care</code> and <code>singletons</code> (the usual default). Note that, depending on your Prolog compiler, the <code>read_term/3</code> built-in predicate may report variables that start with an underscore as singleton variables. There is no standard behavior, hence this option.</dd>
	</dl>


<h4>Documenting flags</h4>

	<dl>
		<dt><code>xmldocs(Option)</code></dt>
			<dd>Controls the automatic generation of documenting files in XML format. Possible option values are <code>on</code> (the usual default) and <code>off</code>.</dd>
	</dl>
	<dl>
		<dt><code>xmldir(Directory)</code></dt>
			<dd>Sets the directory to be used to store the automatically generated XML documenting files. The default value is <code>xml_docs</code>, a sub-directory of the source files directory. Use of this flag requires that the read-only flag <code>altdirs</code> be set to <code>on</code> (not supported in some back-end Prolog compilers).</dd>
	</dl>
	<dl>
		<dt><code>xmlspec(Option)</code></dt>
			<dd>Defines the XML documenting files specification format. Possible option values are <code>dtd</code> (for the DTD specification; the usual default) and <code>xsd</code> (for the XML Schema specification). Most XSL processors support DTDs but only some of them support XML Schemas.</dd>
	</dl>
	<dl>
		<dt><code>xmlsref(Option)</code></dt>
			<dd>Sets the reference to the XML specification file in the automatically generated XML documenting files. The default value is <code>local</code>, that is, the reference points to a local DTD or XSD file (respectively, <code>logtalk.dtd</code> or <code>logtalk.xsd</code>), residing in the same directory as the XML file. Other possible values are <code>web</code> (the reference points to an web location, either <code>http://logtalk.org/xml/1.3/logtalk.dtd</code> or <code>http://logtalk.org/xml/1.3/logtalk.xsd</code>), and <code>standalone</code> (no reference to specification files in the XML documenting files). The most appropriated option value depends on the XSL processor you intend to use. Some of them are buggy an may not work with the default option value.</dd>
	</dl>
	<dl>
		<dt><code>xslfile(File)</code></dt>
			<dd>Sets the XSLT file to be used with the automatically generated XML documenting files. The default value is <code>lgtxml.xsl</code>, which allows the XML files to be viewed by simply opening them with recent versions of web navigators which support XSLT transformations (after copying the <code>lgtxml.xsl</code> and of the <code>logtalk.css</code> files to the directory containing the XML files).</dd>
	</dl>

<h4>Other flags</h4>

	<dl>
		<dt><code>report(Option)</code></dt>
			<dd>Controls reporting of each compiled or loaded object, category, or protocol (including compilation and loading warnings). Possible option values are <code>on</code> (verbose, the usual default), <code>warnings</code> (only print warnings), and <code>off</code> (silent compilation and loading, useful for batch processing).</dd>
	</dl>
	<dl>
		<dt><code>code_prefix(Option)</code></dt>
			<dd>Enables the definition of prefix for all functors of Prolog code generated by the Logtalk compiler. The option value must be an atom; the default value is the empty atom (<code>''</code>). Specifying a code prefix provides a way to solve possible conflicts between Logtalk compiled code and other Prolog code. In addition, some Prolog compilers automatically hide predicates whose functor start with a specific prefix such as the character <code>$</code>.</dd>
	</dl>
	<dl>
		<dt><code>debug(Option)</code></dt>
			<dd>Controls the compilation of source files in debug mode (the Logtalk built-in debugger can only be used with files compiled in this mode). Possible option values are <code>on</code> and <code>off</code> (the usual default).</dd>
	</dl>
	<dl>
		<dt><code>complements(Option)</code></dt>
			<dd>Allows objects to be compiled with support for complementing categories turned off in order to improve performance and security. Possible option values are <code>allow</code> and <code>deny</code> (the usual default). This option can be used on a per-object basis. Note that changing this option is of no consequence for objects already compiled and loaded.</dd>
	</dl>
	<dl>
		<dt><code>dynamic_declarations(Option)</code></dt>
			<dd>Allows objects to be compiled with support for dynamic declaration of new predicates turned off in order to improve performance and security. Possible option values are <code>allow</code> and <code>deny</code> (the usual default). This option can be used on a per-object basis. Note that changing this option is of no consequence for objects already compiled and loaded.</dd>
	</dl>
	<dl>
		<dt><code>events(Option)</code></dt>
			<dd>Allows message sending calls to be compiled with event-driven programming support disable in order to improve performance. Possible option values are <code>allow</code> and <code>deny</code> (the usual default). Objects (and categories) compiled with this option set to <code>deny</code> use optimized code for message-sending calls that does not trigger events. As such, this option can be used on a per-object (or per-category) basis. Note that changing this option is of no consequence for objects already compiled and loaded.</dd>
	</dl>
	<dl>
		<dt><code>context_switching_calls</code></dt>
			<dd>Allows context switching calls (<code>&lt;&lt;/2</code>) to be either allowed or denied. Possible flag values are <code>allow</code> and <code>deny</code>. The default flag vale is <code>allow</code>. Note that changing this option is of no consequence for objects already compiled and loaded.</dd>
	</dl>
	<dl>
		<dt><code>startup_message</code></dt>
			<dd>Controls the messages printed by Logtalk at startup. Possible flag values are <code>flags(verbose)</code> (the usual default; prints the Logtalk banner and a list of all default compiler flags), <code>flags(compact)</code> (a more compact listing of the default compiler flags), <code>banner</code> (prints only the Logtalk banner), and <code>none</code> (suppress all startup messages; useful for batch processing).</dd>
	</dl>
	<dl>
		<dt><code>altdirs</code></dt>
			<dd>Allows the use of alternative directories for storing the Prolog files and the XML documenting files resulting from entity compilation. This flag can only be set for Prolog compilers providing the necessary operating-system access predicates for implementing this feature (specifically, a built-in predicate for creating new directories). Possible option values are <code>on</code> and <code>off</code> (the usual default). The names of the alternative directories are specified using the compiler flags <code>tmpdir</code> and <code>xmldir</code>, which are also defined in the configuration files. Make sure the directory names are valid for your operating system before setting this flag on.</dd>
	</dl>
	<dl>
		<dt><code>reload(Option)</code></dt>
			<dd>Defines the reloading behavior for source files. Possible option values are <code>skip</code> (skip loading of already loaded files; this value can be used to get similar functionality to the Prolog directive <code>ensure_loaded/1</code>) and <code>always</code> (always reload files; the usual default when developing). This option must not be used when recompiling source files in debug mode (see <code>debug/1</code> option above).</dd>
	</dl>
	<dl>
		<dt><code>smart_compilation(Option)</code></dt>
			<dd>Controls the use of smart compilation of source files to avoid recompiling files that are unchanged since the last time they are compiled. Possible option values are <code>on</code> and <code>off</code> (the usual default). This option is only supported in some Prolog compilers. It must not be used when recompiling source files in debug mode (see <code>debug/1</code> option above).</dd>
	</dl>
	<dl>
		<dt><code>hook(Object)</code></dt>
			<dd>Allows the definition of compiler hooks that are called for each term read form a source file and for each compiled goal. This option specifies an object (which can be the pseudo-object <code>user</code>) implementing the <code>expanding</code> built-in protocol. The object is expected to define clauses for the <a title="Consult reference manual" href="../refman/methods/term_expansion2.html"><code>term_expansion/2</code></a> and <a title="Consult reference manual" href="../refman/methods/goal_expansion2.html"><code>goal_expansion/2</code></a> predicates. In the case of the <code>term_expansion/2</code> predicate, the first argument is the term read form the source file while the second argument returns a list of terms corresponding to the expansion of the first argument. In the case of the <code>goal_expansion/2</code> predicate, the second argument should be a goal resulting from the expansion of the goal in the first argument. The predicate <code>goal_expansion/2</code> is called on the expanded goals so care must be taken to avoid compilation loops.</dd>
	</dl>
	<dl>
		<dt><code>tmpdir(Directory)</code></dt>
			<dd>Sets the directory to be used to store the temporary files generated when compiling Logtalk source files. The default value is <code>lgt_tmp</code>, a sub-directory of the source files directory. Use of this flag requires that the read-only flag <code>altdirs</code> be set to <code>on</code> (not supported in some back-end Prolog compilers).</dd>
	</dl>

<h3 id="programming_smart">Reloading and smart compilation of source files</h3>

<p>
As a general rule, reloading source files should never occur in production code and should be handled with care in development code. Reloading a Logtalk source file usually requires reloading the intermediate Prolog file that is generated by the Logtalk compiler. The problem is that there is no standard behavior for reloading Prolog files. For static predicates, almost all Prolog compilers replace the old definitions with the new ones. However, for dynamic predicates, the behavior depends on the Prolog compiler. Most compilers replace the old definitions but some of them simply append the new ones, which usually leads to trouble. See the compatibility notes for the back-end Prolog compiler you intend to use for more information. There is an additional potential problem when using multi-threading programming. Reloading a threaded object does not recreate from scratch its old message queue, which may still be in use (e.g. threads may be waiting on it).
</p>
<p>
When using library entities and stable code, you can avoid reloading the corresponding source files (and, therefore, recompiling them) by setting the compiler option <code>reload</code> to <code>skip</code>. For code under development, you can turn on smart compilation of source files to avoid recompiling files that have not been modified since last compilation (assuming that back-end Prolog compiler that you are using supports retrieving of file modification dates). Smart compilation of source files is usually off by default. You can enable it by changing the default flag value in the configuration file, by using the corresponding compiler flag with the compiling and loading built-in predicates, or, for the remaining of a working session, by using the call:
</p>
<pre>| ?- set_logtalk_flag(smart_compilation, on).</pre>
<p>
Some caveats that you should be aware. First, some warnings that might be produced when compiling a source file will not show up if the corresponding object file is up-to-date because the source file is not being (re)compiled. Second, if you are using several Prolog compilers with Logtalk, be sure to perform the first compilation of your source files with smart compilation turned off: the intermediate Prolog files generated by the Logtalk compiler may be not compatible across Prolog compilers or even for the same Prolog compiler across operating systems (e.g. due to the use of different character encodings or end-of-line characters).
</p>

<h3 id="programming_batch">Using Logtalk for batch processing</h3>

<p>
If you use Logtalk for batch processing, you probably want to suppress most, if not all, banners, messages, and warnings that are normally printed by the system. To suppress printing of the Logtalk startup banner and default flags, set the option <code>startup_message</code> in the config file that you are using to <code>none</code>. To suppress printing of compiling and loading messages (including compiling warnings but not compiling error messages), turn off the option <code>report</code>.
</p>


<h2 id="programming_debugging">Debugging Logtalk programs</h2>

<p>
Logtalk defines a built-in pseudo-object named <code>debugger</code>, which implements debugging features similar to those found on most Prolog compilers. However, there are some differences between the usual implementation of Prolog debuggers and the current implementation of the Logtalk debugger that you should be aware. First, unlike some Prolog debuggers, the Logtalk debugger is not implemented as a meta-interpreter. This translates to a different, although similar, set of debugging features with some limitations when compared with some Prolog debuggers. Second, debugging is only possible for objects compiled in debug mode. When compiling an object in debug mode, Logtalk keeps each clause goal in both source form and compiled form in order to allow tracing of the goal execution. Third, implementation of spy points allows the user to specify the execution context for entering the debugger. This feature is a consequence of the encapsulation of predicates inside objects.
</p>

<h3 id="programming_debugmode">Compiling entities in debug mode</h3>

<p>
Compilation of source files in debug mode is controlled by the compiler flag <code>debug</code>. The default value for this flag, usually <code>off</code>, is defined in the config files. Its value may be changed at runtime by writing:
</p>
<pre>| ?- set_logtalk_flag(debug, on).

yes</pre>
<p>
In alternative, if we want to compile only some entities in debug mode, we may instead write:
</p>
<pre>| ?- logtalk_load([file1, file2, ...], [debug(on)]).</pre>
<p>
The compiler flag <code>smart_compilation</code> is automatically turned off whenever the debug flag is turned on at runtime. This is necessary because debug code would not be generated for files previously compiled in normal mode if there is no changes to the source files. However, note that you should be careful to not turn both flags on at the same time in a config file.
</p>
<p>We may check or enumerate, by backtracking, all loaded entities compiled in debug mode as follows:
</p>
<pre>| ?- debugger::debugging(Entity).</pre>

<h3 id="programming_boxmodel">Logtalk Procedure Box model</h3>

<p>
Logtalk uses a <em>Procedure Box model</em> similar to those found on most Prolog compilers. The traditional Prolog procedure box model uses four ports (<em>call</em>, <em>exit</em>, <em>redo</em>, and <em>fail</em>) for describing control flow when a predicate clause is used during program execution: 
</p>
<dl>
	<dt><code>call</code></dt>
		<dd>predicate call</dd>
	<dt><code>exit</code></dt>
		<dd>success of a predicate call</dd>
	<dt><code>redo</code></dt>
		<dd>backtracking into a predicate</dd>
	<dt><code>fail</code></dt>
		<dd>failure of a predicate call</dd>
</dl>
<p>
Logtalk, as found on some recent Prolog compilers, adds a port for dealing with exceptions thrown when calling a predicate:
</p>
<dl>
	<dt><code>exception</code></dt>
		<dd>predicate call throws an exception</dd>
</dl>
<p>
In addition to the ports described above, Logtalk adds two more ports, <em>fact</em> and <em>rule</em>, which show the result of the unification of a goal with, respectively, a fact and a rule head:
</p>
<dl>
	<dt><code>fact</code></dt>
		<dd>unification success between a goal and a fact</dd>
	<dt><code>rule</code></dt>
		<dd>unification success between a goal and a rule head</dd>
</dl>
<p>
For static predicates, the debugger prints the clause number at the unification ports: <code>Fact #N</code> or <code>Rule #N</code> indicates that clause <code>N</code> is being used for proving a goal.
</p>
<p>
The user may define for which ports the debugger should pause for user interaction by specifying a list of leashed ports. For example:
</p>
<pre>| ?- debugger::leash([call, exit, fail]).</pre>
<p>
Alternatively, the user may use an atom abbreviation for a pre-defined set of ports. For example:
</p>
<pre>| ?- debugger::leash(loose).</pre>
<p>
The abbreviations defined in Logtalk are similar to those defined on some Prolog compilers:
</p>
<dl>
	<dt><code>none</code></dt>
		<dd><code>[]</code></dd>
	<dt><code>loose</code></dt>
		<dd><code>[fact, rule, call]</code></dd>
	<dt><code>half</code></dt>
		<dd><code>[fact, rule, call, redo]</code></dd>
	<dt><code>tight</code></dt>
		<dd><code>[fact, rule, call, redo, fail, exception]</code></dd>
	<dt><code>full</code></dt>
		<dd><code>[fact, rule, call, exit, redo, fail, exception]</code></dd>
</dl>

<h3>Defining spy points<a id="programming_spypoints"></a></h3>

<p>
Logtalk spy points can be defined by simply stating which predicates should be spied, as in most Prolog debuggers, or by fully specifying the context for activating a spy point. 
</p>

<h4>Defining predicate spy points<a id="programming_pspypoints"></a></h4>

<p>
Predicate spy points are specified using the method <code>spy/1</code>. The argument can be either a predicate indicator (<code>Functor/Arity</code>) or a list of predicate indicators. For example:
</p>
<pre>| ?- debugger::spy(foo/2).

Spy points set.
yes

| ?- debugger::spy([foo/4, bar/1]).

Spy points set.
yes</pre>
<p>
Predicate spy points can be removed by using the method <code>nospy/1</code>. The argument can be a predicate indicator, a list of predicate indicators, or a non-instantiated variable in which case all predicate spy points will be removed. For example:
</p>
<pre>| ?- debugger::nospy(_).

All matching predicate spy points removed.
yes</pre>

<h4>Defining context spy points<a id="programming_cspypoints"></a></h4>

<p>
A context spy point is a term describing a message execution context and a goal:
</p>
<pre>(Sender, This, Self, Goal)</pre>
<p>
The debugger is evoked whenever the execution context is true and when the spy point goal unifies with the goal currently being executed. Variable bindings resulting from the unification between the current goal and the goal argument are discarded. The user may establish any number of context spy points as necessary. For example, in order to call the debugger whenever a predicate defined on an object named <code>foo</code> is called we may define the following spy point:
</p>
<pre>| ?- debugger::spy(_, foo, _, _).

Spy point set.
yes</pre>
<p>
For example, we can spy all calls to a <code>foo/2</code> predicate by setting the condition:
</p>
<pre>| ?- debugger::spy(_, _, _, foo(_, _)).

Spy point set.
yes</pre>
<p>
The method <code>nospy/4</code> may be used to remove all matching spy points. For example, the call: 
</p>
<pre>| ?- debugger::nospy(_, _, foo, _).

All matching context spy points removed.
yes</pre>
<p>
will remove all context spy points where the value of <em>Self</em> matches the name <code>foo</code>.
</p>

<h4>Removing all spy points<a id="programming_nospyall"></a></h4>

<p>
We may remove all predicate spy points and all context spy points by using the method <code>nospyall/0</code>:
</p>
<pre>| ?- debugger::nospyall.

All predicate spy points removed.
All context spy points removed.
yes</pre>

<h3 id="programming_trace">Tracing program execution</h3>

<p>
Logtalk allows tracing of execution for all objects compiled in debug mode. To start the debugger in trace mode, write:
</p>
<pre>| ?- debugger::trace.

yes</pre>
<p>
Note that, when tracing, spy points will be ignored. While tracing, the debugger will pause for user input at each leashed port, printing an informative message with the port name and the current goal. After the port name, the debugger prints the goal invocation number (except for the unification ports). This invocation number is unique and can be used to correlate the port trace messages.
</p>
<p>
To stop tracing and turning off the debugger, write:
</p>
<pre>| ?- debugger::notrace.

yes</pre>


<h3 id="programming_debug">Debugging using spy points</h3>

<p>
Tracing a program execution may generate large amounts of debugging data. Debugging using spy points allows the user to concentrate its attention in specific points of its code. To start a debugging session using spy points, write:
</p>
<pre>| ?- debugger::debug.

yes</pre>
<p>
At the beginning of a port description, the debugger will print a <code>+</code> or a <code>*</code> before the current goal if there is, respectively, a predicate spy point or a context spy point defined.
</p>
<p>
To stop the debugger, write:
</p>
<pre>| ?- debugger::nodebug.

yes</pre>
<p>
Note that stopping the debugger does not remove any defined spy points.
</p>

<h3 id="programming_commands">Debugging commands</h3>

<p>
The debugger pauses at leashed posts when tracing or when finding a spy point for user interaction. The commands available are as follows:
</p>
<dl>
	<dt><code>c</code> &mdash; creep</dt>
		<dd>go on; you may use the spacebar, return, or enter keys in alternative</dd>
	<dt><code>l</code> &mdash; leap</dt>
		<dd>continues execution until the next spy point is found</dd>
	<dt><code>s</code> &mdash; skip</dt>
		<dd>skips debugging for the current goal; only meaningful at call and redo ports</dd>
	<dt><code>i</code> &mdash; ignore</dt>
		<dd>ignores goal, assumes that it succeeded; only valid at call and redo ports</dd>
	<dt><code>f</code> &mdash; fail</dt>
		<dd>forces backtracking; may also be used to convert an exception into a failure</dd>
	<dt><code>n</code> &mdash; nodebug</dt>
		<dd>turns off debugging</dd>
	<dt><code>@</code> &mdash; command; <code>!</code> can be used in alternative</dt>
		<dd>reads and executes a query</dd>
	<dt><code>b</code> &mdash; break</dt>
		<dd>suspends execution and starts new interpreter; type <code>end_of_file</code> to terminate</dd>
	<dt><code>a</code> &mdash; abort</dt>
		<dd>returns to top level interpreter</dd>
	<dt><code>q</code> &mdash; quit</dt>
		<dd>quits Logtalk</dd>
	<dt><code>d</code> &mdash; display</dt>
		<dd>writes current goal without using operator notation</dd>
	<dt><code>x</code> &mdash; context</dt>
		<dd>prints execution context</dd>
	<dt><code>e</code> &mdash; exception</dt>
		<dd>prints exception term thrown by the current goal</dd>
	<dt><code>=</code> &mdash; debugging</dt>
		<dd>prints debugging information</dd>
	<dt><code>*</code> &mdash; add</dt>
		<dd>adds a context spy point for the current goal</dd>
	<dt><code>+</code> &mdash; add</dt>
		<dd>adds a predicate spy point for the current goal</dd>
	<dt><code>-</code> &mdash; remove</dt>
		<dd>removes a predicate spy point for the current goal</dd>
	<dt><code>h</code> &mdash; help</dt>
		<dd>prints list of command options; <code>?</code> can be used in alternative</dd>
</dl>

<h3 id="programming_context">Context-switching calls</h3>

<p>
Logtalk provides a control construct, <a title="Consult reference manual" href="../refman/control/context2.html"><code>&lt;&lt;/2</code></a>, which allows the execution of a query within the context of an object. Common debugging uses include checking an object local predicates (e.g. predicates representing internal dynamic state) and sending a message from within an object. This control construct may also be used to write unit tests.
</p>
<p>
Consider the following toy example:
</p>
<pre>:- object(broken).

    :- public(a/1).
    :- private([b/2, c/1]).
    :- dynamic(c/1).

    a(A) :- b(A, B), c(B).
    b(1, 2). b(2, 4). b(3, 6).
    c(3).    % in a real-life example, this would be a clause asserted at runtime

:- end_object.
</pre>
<p>
Something is wrong when we try the object public predicate, <code>a/1</code>:
</p>
<pre>| ?- broken::a(A).

no</pre>
<p>
For helping diagnosing the problem, instead of compiling the object in debug mode and doing a <em>trace</em> of the query to check the clauses for the non-public predicates, we can instead simply type:
</p>
<pre>| ?- broken &lt;&lt; c(C).

C = 3
yes
</pre>
<p>
The <code>&lt;&lt;/2</code> control construct works by switching the execution context to the object in the first argument and then compiling and executing the second argument within that context:
</p>
<pre>| ?- broken &lt;&lt; (self(Self), sender(Sender), this(This)).

Self = broken
Sender = broken
This = broken

yes</pre>
<p>
As exemplified above, the <code>&lt;&lt;/2</code> control construct allows you to call an object local and private predicates. However, it is important to stress that we are not bypassing or defeating an object predicate scope directives. The calls take place within the context of the specified object, not within the context of the object making the <code>&lt;&lt;/2</code> call. Thus, the <code>&lt;&lt;/2</code> control construct  implements a form of <em>execution-context switching</em>.
</p>
<p>
The availability of the <code>&lt;&lt;/2</code> control construct is controlled by the read-only compiler flag <code>context_switching_calls</code>, which is defined in the config files of the back-end Prolog compilers.
</p>

<h3 id="programming_hooks">Using compilation hooks and term expansion for debugging</h3>

<p>
It is possible to use compilation hooks and the term expansion mechanism for conditional compilation of debugging goals. Assume that we chose the predicate <code>debug/1</code> to represent debug goals. For example:
</p>
<pre>append([], List, List) :-
    debug((write('Base case: '), writeq(append([], List, List)), nl)).
append([Head| Tail], List, [Head| Tail2]) :-
    debug((write('Recursive case: '), writeq(append(Tail, List, Tail2)), nl)),
    append(Tail, List, Tail2).</pre>
<p>
When debugging, we want to call the argument of the predicate <code>debug/1</code>. This can be easily accomplished by defining a hook object containing the following definition for <code>goal_expansion/2</code>:
</p>
<pre>goal_expansion(debug(Goal), Goal).</pre>
<p>
When not debugging, we can use a second hook object to discard the <code>debug/1</code> calls by defining the predicate <code>goal_expansion/2</code> as follows:
</p>
<pre>goal_expansion(debug(_), true).</pre>
<p>
The Logtalk compiler automatically removes any redundant calls to the built-in predicate <code>true/0</code> when compiling object predicates.
</p>

<div class="footer">
	<div class="copyright">
		<span>Copyright &copy; <a href="mailto:pmoura@logtalk.org">Paulo Moura</a> &mdash; <a href="http://logtalk.org">Logtalk.org</a></span><br/>	
		<span>Last updated on: March 21, 2009</span>
	</div>
	<div class="navbottom">
		<span><a href="installing.html">previous</a> | <a href="../glossary.html">glossary</a> | <a href="migration.html">next</a></span><br/>
		<span><a href="http://validator.w3.org/check/referer">XHTML</a> + <a href="http://jigsaw.w3.org/css-validator/check/referer">CSS</a></span>
	</div>
</div>

</body>

</html>
