<?xml version="1.0" encoding="iso-8859-1"?>
<?xml-stylesheet type="text/css" href="../styles.css" ?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">

<head>
	<meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
	<title>Logtalk user manual: message sending</title>
	<link rel="stylesheet" href="../styles.css" type="text/css" />
</head>

<body>

<div class="navtop">
<a href="../index.html">contents</a> &gt; <a href="index.html">user manual</a>
</div>

<h1>Message sending</h1>

<p>
Note that message sending is only the same as calling an object's predicate if the object does not inherit (or import) predicate definitions from other objects (or categories). Otherwise, the predicate definition that will be executed may depend on the relationships of the object with other Logtalk entities.
</p>

<h2>Operators used in message sending<a name="operators"></a></h2>

<p>
Logtalk uses the following three operators for message sending:
</p>
<pre>
    :- op(600, xfx, ::).
    :- op(600,  fx, ::).
    :- op(600,  fx, ^^).
</pre>
<p>
It is assumed that these operators remain active (once the Logtalk preprocessor and runtime files are loaded) until the end of the Prolog session (this is the usual behaviour of most Prolog compilers). Note that these operator definitions are compatible with the pre-defined operators in the Prolog ISO standard.
</p>

<h2>Sending a message to an object<a name="sending"></a></h2>

<p>
Sending a message to an object is done by using the <a title="Consult reference manual" href="../refman/control/to_object2.html"><code>::/2</code></a> infix  operator:
</p>
<pre>
    | ?- Object::Message.
</pre>
<p>
The message must match a public predicate declared for the receiving object or a Logtalk/Prolog built-in predicate, otherwise an error will be thrown (see the Reference Manual for details).
</p>

<h2>Broadcasting<a name="broadcasting"></a></h2>

<p>
In the Logtalk context, broadcasting is interpreted as the sending of the same message to a group of objects or the sending of several messages to the same object. Both needs can be achieved by using the message sending method described above. However, for convenience, Logtalk implements an extended syntax for message sending that makes programming easier in these situations.
</p>
<p>
If we wish to send several messages to the same object, we can write:
</p>
<pre>
    | ?- Object::(Message1, Message2, ...).
</pre>
<p>
This is semantically equivalent to:
</p>
<pre>
    | ?- Object::Message1, Object::Message2, ... .
</pre>
<p>
We can also write:
</p>
<pre>
    | ?- Object::(Message1; Message2; ...).
</pre>
<p>
This will be semantically equivalent to writing:
</p>
<pre>
    | ?- Object::Message1; Object::Message2; ... .
</pre>
<p>
To send the same message to a set of objects we can write:
</p>
<pre>
    | ?- (Object1, Object2, ...)::Message.
</pre>
<p>
This will have the same semantics as:
</p>
<pre>
    | ?- Object1::Message, Object2::Message, ... .
</pre>
<p>
If we want to use backtracking to try the same message over a set of objects we can write:
</p>
<pre>
    | ?- (Object1; Object2, ...)::Message.
</pre>
<p>
This will be equivalent to:
</p>
<pre>
    | ?- Object1::Message; Object2::Message; ... .
</pre>

<h2>Sending a message to <em>self</em><a name="self"></a></h2>

<p>
While defining a predicate, we sometimes need to send a message to <em>self</em>, that is, to the same object that has received the original message. This is done in Logtalk through the <a title="Consult reference manual" href="../refman/control/to_self1.html"><code>::/1</code></a> prefix operator:
</p>
<pre>
    ::Message
</pre>
<p>
We can also use the broadcasting constructs with this operator:
</p>
<pre>
    ::(Message1, Message2, ...)
</pre>
<p>
or:
</p>
<pre>
    ::(Message1; Message2; ...)
</pre>
<p>
The message must match a public or protected predicate declared for the receiving object or a Logtalk/Prolog built-in predicate otherwise an error will be thrown (see the Reference Manual for details). If the message is sent from inside a category or if we are using private inheritance, then the message may also match a private predicate.
</p>

<h2>Calling an overridden predicate definition<a name="super"></a></h2>

<p>
When redefining a predicate, we sometimes have the need to call the inherited definition in the new code. This possibility, introduced by the Smalltalk language through the <code>super</code> primitive, is available in Logtalk through the <a title="Consult reference manual" href="../refman/control/to_super1.html"><code>^^/1</code></a> prefix operator:
</p>
<pre>
    ^^Predicate
</pre>
<p>
Most of the time we will use this operator by instantiating the pattern:
</p>
<pre>
    Predicate :-
        ...,            % do something
        ^^Predicate,    % call inherited definition
        ... .           % do something more
</pre>

<h2>Message sending and event generation<a name="events"></a></h2>

<p>
Every message sent using <a title="Consult reference manual" href="../refman/control/to_object2.html"><code>::/2</code></a> operator generates two events, one before and one after the message execution. Messages that are sent using the <a title="Consult reference manual" href="../refman/control/to_self1.html"><code>::/1</code></a> (message to <em>self</em>) operator or the <a title="Consult reference manual" href="../refman/control/to_super1.html"><code>^^/1</code></a> super mechanism described above do not generate any events. The rational behind this distinction is that messages to <em>self</em> and <em>super</em> calls are only used indirectly in the definition of methods or to execute aditional messages with the same target object (represented by <em>self</em>). In other words, events are only generated when using an object's public interface. They can not be used to break object encapsulation.
</p>
<p>
If we need to generate events for a public message sent to <em>self</em>, then we just need to write something like:
</p>
<pre>
    Predicate :-
        ...,
        self(Self),       % get self reference
        Self::Message,    % send a message to self using ::/2
        ... .
</pre>
<p>
If we also need the sender of the message to be other than the object containing the predicate definition, we can write:
</p>
<pre>
    Predicate :-
        ...,
        self(Self),         % get self reference
        {Self::Message},    % send a message to self using ::/2
        ... .               % sender will be the pseudo-object user
</pre>
<p>
See the session on <a href="events.html">Event-driven programming</a> for more details.
</p>

<h2>Message sending performace<a name="performace"></a></h2>

<p>
Logtalk implements dynamic binding, coupled with a cache mechanism which avoids repeated lookups of predicate declarations and predicate definitions for the same messages. This is a solution common to other programming languages supporting dynamic binding. Message lookups are automatically cached the first time a message is sent. Cache entries are automatically removed when loading entities or using Logtalk dynamic features which invalidates the cached lookups.
</p>
<p>
When discussing Logtalk message sending performance, two distinct cases should be considered: messages sent by the user from the top-level interpreter and messages sent from compiled objects. In addition, the message declaration and definition lookups may, or may not be already cached by the runtime engine. In what follows, we will assume that the message lookups are already cached.
</p>
<p>
A message sent from a compiled object to another object takes six logical inferences:
</p>
<ul>
	<li>cache lookup &mdash; 1 logical inference</li>
	<li>event checking &mdash; 4 logical inferences (assuming that no events are defined)</li>
	<li>method call &mdash; 1 logical inference</li>
</ul>
<p>
Given that events can be dynamically defined at runtime, there is no room for reducing the number of logical inferences without droping support for event-driven programming. When events are defined, the number of logical inferences grows proportional to the number of events and event handlers (monitors).
</p>
<p>
Messages to <em>self</em> and <em>super</em> calls are transparent regarding events and, as such, imply only two logical inferences. This compares with one logical inference when calling a predicate in plain Prolog and one or two logical inferences when calling a predicate encapsulated in a module.
<p>
When a message is sent by the user from the top-level interpreter, Logtalk needs to perform a runtime translation of the message sending in order to prove the corresponding goal. The overhead, for user-defined messages/predicates, corresponds to roughly seventeen more logic inferences than that of the same message when sent from a compiled object. Considering the time taken for the user to type the goal, this overhead is of no practical consequence.
</p>
<p>
When a message is not cached, the number of logical inferences depends on the number of steps needed for the Logtalk runtime engine to lookup the corresponding predicate scope declaration (to check if the message is valid) and then to lookup a predicate definition for answering the message.
</p>

<div class="navbottom">
<a href="features.html">previous</a> | <a href="../glossary.html">glossary</a> | <a href="objects.html">next</a>
</div>

<div class="copyright">
Copyright &copy; <a href="mailto:pmoura@logtalk.org">Paulo Moura</a> &mdash; <a href="http://www.logtalk.org">Logtalk.org</a>
</div>

<div class="footer">
<p><span class="bleft"><a href="http://validator.w3.org/check/referer">XHTML</a> + <a href="http://jigsaw.w3.org/css-validator/check/referer">CSS</a></span><span class="bright">Last updated on: October 20, 2004</span></p>
</div>
</body>
</html>
