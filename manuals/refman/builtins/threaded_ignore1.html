<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">

<head>
	<meta http-equiv="content-type" content="application/xml+xhtml; charset=utf-8" />
	<title>Logtalk built-in predicate: threaded_ignore/1</title>
	<link rel="stylesheet" href="../../screen.css" type="text/css" media="screen"/>
	<link rel="stylesheet" href="../../print.css" type="text/css" media="print"/>
</head>

<body>

<div class="top-left">Logtalk reference manual</div> 
<div class="top-right">Built-in predicate: threaded_ignore/1</div>
<div class="bottom-left"><span class="page"/></div> 
<div class="bottom-right"><span class="page"/></div>
<div class="navtop"><a href="../../index.html">contents</a> &gt; <a href="../index.html">reference manual</a> &gt; <a href="../index.html#builtins">built-in predicates</a></div>

<h2 class="codenp">threaded_ignore/1<span id="builtins_threaded_ignore1"/></h2>


<h4>Description</h4>

<pre>threaded_ignore(Goal)
threaded_ignore((Goal1, Goal2, ...))
threaded_ignore((Goal1; Goal2; ...))</pre>
<p>
Prove <code>Goal</code> asynchronously using a new thread. Only the first solution for the goal is found. The argument can be a message sending. This call always succeeds, independently of the result (success, failure, or exception), which is simply discarded instead of being sent back to the thread of the object containing the call (<em>this</em>).
</p>
<p>
When the argument is a <em>conjunction</em> of goals, the call is equivalent to the conjunction of calls of the individual goals. However, when the argument is a <em>disjunction</em> of goals, the call is equivalent to the <em>competing</em> calls of the individual goals: when one of the goals complete, the other ones are aborted (i.e. their threads are terminated). In this case, the corresponding <code>threaded_exit/1</code> goal <strong>must</strong> match all the goals in the disjunction. This is useful when you have a set of different methods to solve a problem without knowing a priori which one will lead to the fastest result.
</p>

<h4>Template and modes</h4>

<pre>threaded_ignore(+callable)</pre>

<h4>Errors</h4>

<dl>
	<dt>Goal is a variable:</dt>
		<dd><code>instantiation_error</code></dd>
	<dt>Goal is neither a variable nor a callable term:</dt>
		<dd><code>type_error(callable, Goal)</code></dd>
</dl>

<h4>Examples</h4>

<dl>
	<dt>Prove <code>Goal</code> asynchronously in a new thread:</dt>
		<dd><code>threaded_ignore(Goal)</code></dd>
	<dt>Send an asynchronous message to <em>self</em>:</dt>
		<dd><code>threaded_ignore(::Message)</code></dd>
	<dt>Send an asynchronous message to an object:</dt>
		<dd><code>threaded_ignore(Object::Message)</code></dd>
</dl>

<div class="footer">
	<div class="copyright">
		<span>Copyright &copy; <a href="mailto:pmoura@logtalk.org">Paulo Moura</a> &mdash; <a href="http://logtalk.org">Logtalk.org</a></span><br/>	
		<span>Last updated on: November 23, 2006</span>
	</div>
	<div class="navbottom">
		<span><a href="threaded_once1.html">previous</a> | <a href="../../glossary.html">glossary</a> | <a href="threaded_exit1.html">next</a></span><br/>
		<span><a href="http://validator.w3.org/check/referer">XHTML</a> + <a href="http://jigsaw.w3.org/css-validator/check/referer">CSS</a></span>
	</div>
</div>

</body>

</html>
