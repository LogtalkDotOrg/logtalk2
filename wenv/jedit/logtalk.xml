<?xml version="1.0"?>

<!DOCTYPE MODE SYSTEM "xmode.dtd">

<!--	jEdit 4.3 Logtalk syntax file

	written by		Paulo Moura
	version			1.9
	created on		2 May 2002
	last revised	17 March 2007

	To install, copy this file to the "modes" subdirectory in jEdit 
	directory installation.   Next, check the "catalog" file in the 
	same subdirectory and add (if not present) the following entry:
	
	<MODE NAME="logtalk" FILE="logtalk.xml" FILE_NAME_GLOB="*.{lgt,config}" />
-->

<MODE>

	<PROPS>
		<PROPERTY NAME="lineComment" VALUE="%" />
		<PROPERTY NAME="commentStart" VALUE="/*" />
		<PROPERTY NAME="commentEnd" VALUE="*/" />
		<PROPERTY NAME="tabSize" VALUE="4" />
		<PROPERTY NAME="indentSize" VALUE="4" />
        <!-- Auto indent -->
        <PROPERTY NAME="indentNextLine" VALUE="((^\s*:-\s(object|protocol|category)\(.*,$)|.*\s:-$)" />
	</PROPS>

	<RULES SET="MAIN" IGNORE_CASE="FALSE">
	
		<!-- Comments -->
		<EOL_SPAN TYPE="COMMENT1">%</EOL_SPAN>
		<SPAN TYPE="COMMENT1" NO_LINE_BREAK="FALSE">
			<BEGIN>/*</BEGIN>
			<END>*/</END>
		</SPAN>

		<!-- Entity directives -->
		<SEQ_REGEXP AT_WORD_START="TRUE" TYPE="KEYWORD1">^\s*:-\s(category|object|protocol)(?=[(])</SEQ_REGEXP>
		<SEQ_REGEXP AT_WORD_START="TRUE" TYPE="KEYWORD1">^\s*:-\send_(category|object|protocol)(?=[.])</SEQ_REGEXP>
		<SEQ_REGEXP AT_WORD_START="TRUE" TYPE="KEYWORD1">^\s*:-\smodule(?=[(])</SEQ_REGEXP>
 		<!-- Predicate scope directives -->
		<SEQ_REGEXP AT_WORD_START="TRUE" TYPE="KEYWORD1">^\s*:-\sp(ublic|r(otected|ivate))(?=[(])</SEQ_REGEXP>
		<!-- Other directives -->
		<SEQ_REGEXP AT_WORD_START="TRUE" TYPE="KEYWORD1">^\s*:-\se(ncoding|xport)(?=[(])</SEQ_REGEXP>
		<SEQ_REGEXP AT_WORD_START="TRUE" TYPE="KEYWORD1">^\s*:-\sin(fo|itialization)(?=[(])</SEQ_REGEXP>
		<SEQ_REGEXP AT_WORD_START="TRUE" TYPE="KEYWORD1">^\s*:-\s(dynamic|synchronized|threaded)(?=[.])</SEQ_REGEXP>
		<SEQ_REGEXP AT_WORD_START="TRUE" TYPE="KEYWORD1">^\s*:-\s(a(lias|tomic)|d(ynamic|iscontiguous)|m(eta_predicate|ode|ultifile)|synchronized)(?=[(])</SEQ_REGEXP>
		<SEQ_REGEXP AT_WORD_START="TRUE" TYPE="KEYWORD1">^\s*:-\sop(?=[(])</SEQ_REGEXP>
		<SEQ_REGEXP AT_WORD_START="TRUE" TYPE="KEYWORD1">^\s*:-\s(calls|use(s|_module))(?=[(])</SEQ_REGEXP>
		<SEQ_REGEXP AT_WORD_START="TRUE" TYPE="KEYWORD1">(extends|i(nstantiates|mp(lements|orts))|specializes)(?=[(])</SEQ_REGEXP>

		<!-- Event handlers -->
		<SEQ_REGEXP AT_WORD_START="TRUE" TYPE="KEYWORD2">\b(after|before)(?=[(])</SEQ_REGEXP>
		<!-- Method execution context -->
		<SEQ_REGEXP AT_WORD_START="TRUE" TYPE="KEYWORD2">\b(parameter|this|se(lf|nder))(?=[(])</SEQ_REGEXP>
		<!-- Reflection -->
		<SEQ_REGEXP AT_WORD_START="TRUE" TYPE="KEYWORD2">\b(current_predicate|predicate_property)(?=[(])</SEQ_REGEXP>
		<!-- DCGs -->
		<SEQ_REGEXP AT_WORD_START="TRUE" TYPE="KEYWORD2">\b(expand_term|term_expansion|phrase)(?=[(])</SEQ_REGEXP>
		<!-- Entity -->
		<SEQ_REGEXP AT_WORD_START="TRUE" TYPE="KEYWORD2">\b(abolish|c(reate|urrent))_(object|protocol|category)(?=[(])</SEQ_REGEXP>
		<SEQ_REGEXP AT_WORD_START="TRUE" TYPE="KEYWORD2">\b(object|protocol|category)_property(?=[(])</SEQ_REGEXP>
		<!-- Entity relations -->
		<SEQ_REGEXP AT_WORD_START="TRUE" TYPE="KEYWORD2">\bextends_(object|protocol)(?=[(])</SEQ_REGEXP>
		<SEQ_REGEXP AT_WORD_START="TRUE" TYPE="KEYWORD2">\bimplements_protocol(?=[(])</SEQ_REGEXP>
		<SEQ_REGEXP AT_WORD_START="TRUE" TYPE="KEYWORD2">\b(instantiates|specializes)_class(?=[(])</SEQ_REGEXP>
		<SEQ_REGEXP AT_WORD_START="TRUE" TYPE="KEYWORD2">\bimports_category(?=[(])</SEQ_REGEXP>
		<!-- Events -->
		<SEQ_REGEXP AT_WORD_START="TRUE" TYPE="KEYWORD2">\b(current_event|(abolish|define)_events)(?=[(])</SEQ_REGEXP>
		<!-- Flags -->
		<SEQ_REGEXP AT_WORD_START="TRUE" TYPE="KEYWORD2">\b(current|set)_logtalk_flag(?=[(])</SEQ_REGEXP>
		<!-- Compiling, loading, and library paths -->
		<SEQ_REGEXP AT_WORD_START="TRUE" TYPE="KEYWORD2">\blogtalk_(compile|l(ibrary_path|oad))(?=[(])</SEQ_REGEXP>
		<!-- Database -->
		<SEQ_REGEXP AT_WORD_START="TRUE" TYPE="KEYWORD2">\b(clause|retract(all)?)(?=[(])</SEQ_REGEXP>
		<SEQ_REGEXP AT_WORD_START="TRUE" TYPE="KEYWORD2">\ba(bolish|ssert(a|z))(?=[(])</SEQ_REGEXP>
		<!-- Control -->
		<SEQ_REGEXP AT_WORD_START="TRUE" TYPE="KEYWORD2">\b(ca(ll|tch)|throw)(?=[(])</SEQ_REGEXP>
		<SEQ_REGEXP AT_WORD_START="TRUE" TYPE="KEYWORD2">\b(fail|true)\b</SEQ_REGEXP>
		<!-- All solutions -->
		<SEQ_REGEXP AT_WORD_START="TRUE" TYPE="KEYWORD2">\b((bag|set)of|f(ind|or)all)(?=[(])</SEQ_REGEXP>
		<!-- Multi-threading meta-predicates -->
		<SEQ_REGEXP AT_WORD_START="TRUE" TYPE="KEYWORD2">\bthreaded_(call|once|ignore|race|exit|peek|wait|notify)(?=[(])</SEQ_REGEXP>
		<!-- Term unification -->
		<SEQ_REGEXP AT_WORD_START="TRUE" TYPE="KEYWORD2">\bunify_with_occurs_check(?=[(])</SEQ_REGEXP>
		<!-- Term creation and decomposition -->
		<SEQ_REGEXP AT_WORD_START="TRUE" TYPE="KEYWORD2">\b(functor|arg|copy_term)(?=[(])</SEQ_REGEXP>
		<!-- Evaluable functors -->
		<SEQ_REGEXP AT_WORD_START="TRUE" TYPE="KEYWORD2">\b(rem|mod|abs|sign)(?=[(])</SEQ_REGEXP>
		<SEQ_REGEXP AT_WORD_START="TRUE" TYPE="KEYWORD2">\bfloat(_(integer|fractional)_part)?(?=[(])</SEQ_REGEXP>
		<SEQ_REGEXP AT_WORD_START="TRUE" TYPE="KEYWORD2">\b(floor|truncate|round|ceiling)(?=[(])</SEQ_REGEXP>
		<!-- Other arithmetic functors -->
		<SEQ_REGEXP AT_WORD_START="TRUE" TYPE="KEYWORD2">\b(cos|atan|exp|log|s(in|qrt))(?=[(])</SEQ_REGEXP>
		<!-- Term testing -->
		<SEQ_REGEXP AT_WORD_START="TRUE" TYPE="KEYWORD2">\b(var|atom(ic)?|integer|float|compound|n(onvar|umber))(?=[(])</SEQ_REGEXP>
		<!-- Stream selection and control -->
		<SEQ_REGEXP AT_WORD_START="TRUE" TYPE="KEYWORD2">\b(current|set)_(in|out)put(?=[(])</SEQ_REGEXP>
		<SEQ_REGEXP AT_WORD_START="TRUE" TYPE="KEYWORD2">\b(open|close)(?=[(])</SEQ_REGEXP>
		<SEQ_REGEXP AT_WORD_START="TRUE" TYPE="KEYWORD2">\bflush_output(?=[(])</SEQ_REGEXP>
		<SEQ_REGEXP AT_WORD_START="TRUE" TYPE="KEYWORD2">\bflush_output\b</SEQ_REGEXP>
		<SEQ_REGEXP AT_WORD_START="TRUE" TYPE="KEYWORD2">\b(stream_property|at_end_of_stream|set_stream_position)(?=[(])</SEQ_REGEXP>
		<!-- Character and byte input/output -->
		<SEQ_REGEXP AT_WORD_START="TRUE" TYPE="KEYWORD2">\b(nl|(get|peek|put)_(byte|c(har|ode)))(?=[(])</SEQ_REGEXP>
		<SEQ_REGEXP AT_WORD_START="TRUE" TYPE="KEYWORD2">\bnl\b</SEQ_REGEXP>
		<!-- Term input/output -->
		<SEQ_REGEXP AT_WORD_START="TRUE" TYPE="KEYWORD2">\bread(_term)?(?=[(])</SEQ_REGEXP>
		<SEQ_REGEXP AT_WORD_START="TRUE" TYPE="KEYWORD2">\bwrite(q|_(canonical|term))?(?=[(])</SEQ_REGEXP>
		<SEQ_REGEXP AT_WORD_START="TRUE" TYPE="KEYWORD2">\b(current_)?op(?=[(])</SEQ_REGEXP>
		<SEQ_REGEXP AT_WORD_START="TRUE" TYPE="KEYWORD2">\b(current_)?char_conversion(?=[(])</SEQ_REGEXP>
		<!-- Atomic term processing -->
		<SEQ_REGEXP AT_WORD_START="TRUE" TYPE="KEYWORD2">\batom_(length|c(hars|o(ncat|des)))(?=[(])</SEQ_REGEXP>
		<SEQ_REGEXP AT_WORD_START="TRUE" TYPE="KEYWORD2">\b(char_code|sub_atom)(?=[(])</SEQ_REGEXP>
		<SEQ_REGEXP AT_WORD_START="TRUE" TYPE="KEYWORD2">\bnumber_c(hars|odes)(?=[(])</SEQ_REGEXP>
		<!-- Implementation defined hooks functions -->
		<SEQ_REGEXP AT_WORD_START="TRUE" TYPE="KEYWORD2">\b(set|current)_prolog_flag(?=[(])</SEQ_REGEXP>
		<SEQ_REGEXP AT_WORD_START="TRUE" TYPE="KEYWORD2">\bhalt\b</SEQ_REGEXP>
		<SEQ_REGEXP AT_WORD_START="TRUE" TYPE="KEYWORD2">\bhalt(?=[(])</SEQ_REGEXP>
		<!-- Logic and control -->
		<SEQ_REGEXP AT_WORD_START="TRUE" TYPE="KEYWORD2">\bonce(?=[(])</SEQ_REGEXP>
		<SEQ_REGEXP AT_WORD_START="TRUE" TYPE="KEYWORD2">\brepeat\b</SEQ_REGEXP>

		<!-- Variables -->
		<SEQ_REGEXP HASH_CHARS="_ABCDEFGHIJKLMNOPQRSTUVWXYZ" AT_WORD_START="TRUE" TYPE="MARKUP">[_A-Z]+[a-zA-Z0-9]*</SEQ_REGEXP>

		<!-- Character code constants -->
		<SEQ_REGEXP TYPE="DIGIT" HASH_CHAR="0">0'[[:alnum:]]</SEQ_REGEXP>
		<!-- Binary, octal, and hexadecimal numbers -->
		<SEQ_REGEXP TYPE="DIGIT" HASH_CHAR="0">0b[0-1]+</SEQ_REGEXP>
		<SEQ_REGEXP TYPE="DIGIT" HASH_CHAR="0">0o[0-7]+</SEQ_REGEXP>
		<SEQ_REGEXP TYPE="DIGIT" HASH_CHAR="0">0x[[:xdigit:]]+</SEQ_REGEXP>

		<!-- String literals -->
		<SPAN TYPE="LITERAL1" NO_LINE_BREAK="TRUE">
			<BEGIN>'</BEGIN>
			<END>'</END>
		</SPAN>
		<SPAN TYPE="LITERAL1" NO_LINE_BREAK="TRUE">
			<BEGIN>"</BEGIN>
			<END>"</END>
		</SPAN>

		<!-- External call -->
		<SPAN TYPE="OPERATOR" DELEGATE="MAIN">
			<BEGIN>{</BEGIN>
			<END>}</END>
		</SPAN>

		<!-- Numbers -->
		<SEQ_REGEXP AT_WORD_START="TRUE" HASH_CHAR="0" TYPE="DIGIT">0'.</SEQ_REGEXP>
		<SEQ_REGEXP AT_WORD_START="TRUE" HASH_CHAR="0" TYPE="DIGIT">0b[0-1]+</SEQ_REGEXP>
		<SEQ_REGEXP AT_WORD_START="TRUE" HASH_CHAR="0" TYPE="DIGIT">0o[0-7]+</SEQ_REGEXP>
		<SEQ_REGEXP AT_WORD_START="TRUE" HASH_CHAR="0" TYPE="DIGIT">0x[0-9a-fA-F]+</SEQ_REGEXP>
		<SEQ_REGEXP AT_WORD_START="TRUE" TYPE="DIGIT">\d+(\.\d+)?([eE]([-+])?\d+)?</SEQ_REGEXP>

		<!-- Logtalk message sending operators -->
		<SEQ TYPE="OPERATOR">::</SEQ>
		<SEQ TYPE="OPERATOR">^^</SEQ>

			<!-- Control constructs -->
			<SEQ TYPE="OPERATOR">!</SEQ>
			<SEQ TYPE="OPERATOR">,</SEQ>
			<SEQ TYPE="OPERATOR">;</SEQ>
			<SEQ TYPE="OPERATOR">--&gt;</SEQ>
			<SEQ TYPE="OPERATOR">-&gt;</SEQ>

			<!-- Term unification -->
			<SEQ TYPE="OPERATOR">=</SEQ>
			<SEQ TYPE="OPERATOR">\=</SEQ>

			<!-- Term comparison -->
			<SEQ TYPE="OPERATOR">@=&lt;</SEQ>
			<SEQ TYPE="OPERATOR">==</SEQ>
			<SEQ TYPE="OPERATOR">\==</SEQ>
			<SEQ TYPE="OPERATOR">@&lt;</SEQ>
			<SEQ TYPE="OPERATOR">@&gt;</SEQ>
			<SEQ TYPE="OPERATOR">@&gt;=</SEQ>

			<!-- Term creation and decomposition -->
			<SEQ TYPE="OPERATOR">=..</SEQ>

			<!-- Arithemtic evaluation -->
			<OPERATOR>is</OPERATOR>

			<!-- Arithemtic comparison -->
			<SEQ TYPE="OPERATOR">=:=</SEQ>
			<SEQ TYPE="OPERATOR">=\=</SEQ>
			<SEQ TYPE="OPERATOR">&lt;</SEQ>
			<SEQ TYPE="OPERATOR">=&lt;</SEQ>
			<SEQ TYPE="OPERATOR">&gt;</SEQ>
			<SEQ TYPE="OPERATOR">&gt;=</SEQ>

			<!-- Logic and control -->
			<SEQ TYPE="OPERATOR">\+</SEQ>

			<!-- Evaluable functors -->
			<SEQ TYPE="OPERATOR">+</SEQ>
			<SEQ TYPE="OPERATOR">-</SEQ>
			<SEQ TYPE="OPERATOR">*</SEQ>
			<SEQ TYPE="OPERATOR">//</SEQ>
			<SEQ TYPE="OPERATOR">/</SEQ>

			<!-- Other arithemtic functors -->
			<SEQ TYPE="OPERATOR">**</SEQ>

			<!-- Bitwise functors -->
			<SEQ TYPE="OPERATOR">&gt;&gt;</SEQ>
			<SEQ TYPE="OPERATOR">&lt;&lt;</SEQ>
			<SEQ TYPE="OPERATOR">/\</SEQ>
			<SEQ TYPE="OPERATOR">\/</SEQ>
			<SEQ TYPE="OPERATOR">\</SEQ>

			<!-- Clause operators -->
			<SEQ TYPE="OPERATOR">.</SEQ>
			<SEQ_REGEXP TYPE="OPERATOR">\s:-($|\s)</SEQ_REGEXP>

		<KEYWORDS AT_WORD_START="TRUE"> <!-- just for code completion to work! -->

			<NULL>abolish</NULL>
			<NULL>abolish_category</NULL>
			<NULL>abolish_events</NULL>
			<NULL>abolish_object</NULL>
			<NULL>abolish_protocol</NULL>
			<NULL>after</NULL>
			<NULL>alias</NULL>
			<NULL>arg</NULL>
			<NULL>asserta</NULL>
			<NULL>assertz</NULL>
			<NULL>atom</NULL>
			<NULL>atomic</NULL>
			<NULL>atom_chars</NULL>
			<NULL>atom_codes</NULL>
			<NULL>atom_concat</NULL>
			<NULL>atom_length</NULL>
			<NULL>at_end_of_stream</NULL>
			<NULL>bagof</NULL>
			<NULL>before</NULL>
			<NULL>call</NULL>
			<NULL>calls</NULL>
			<NULL>catch</NULL>
			<NULL>category</NULL>
			<NULL>category_property</NULL>
			<NULL>char_code</NULL>
			<NULL>char_conversion</NULL>
			<NULL>clause</NULL>
			<NULL>close</NULL>
			<NULL>compound</NULL>
			<NULL>copy_term</NULL>
			<NULL>create_category</NULL>
			<NULL>create_object</NULL>
			<NULL>create_protocol</NULL>
			<NULL>current_category</NULL>
			<NULL>current_char_conversion</NULL>
			<NULL>current_event</NULL>
			<NULL>current_input</NULL>
			<NULL>current_logtalk_flag</NULL>
			<NULL>current_object</NULL>
			<NULL>current_op</NULL>
			<NULL>current_output</NULL>
			<NULL>current_predicate</NULL>
			<NULL>current_prolog_flag</NULL>
			<NULL>current_protocol</NULL>
			<NULL>define_events</NULL>
			<NULL>discontiguous</NULL>
			<NULL>dynamic</NULL>
			<NULL>encoding</NULL>
			<NULL>end_category</NULL>
			<NULL>end_object</NULL>
			<NULL>end_protocol</NULL>
			<NULL>expand_term</NULL>
			<NULL>extends</NULL>
			<NULL>extends_object</NULL>
			<NULL>extends_protocol</NULL>
			<NULL>fail</NULL>
			<NULL>findall</NULL>
			<NULL>float</NULL>
			<NULL>flush_output</NULL>
			<NULL>forall</NULL>
			<NULL>functor</NULL>
			<NULL>get_byte</NULL>
			<NULL>get_char</NULL>
			<NULL>get_code</NULL>
			<NULL>halt</NULL>
			<NULL>implements</NULL>
			<NULL>implements_protocol</NULL>
			<NULL>imports</NULL>
			<NULL>imports_category</NULL>
			<NULL>info</NULL>
			<NULL>initialization</NULL>
			<NULL>instantiates</NULL>
			<NULL>instantiates_class</NULL>
			<NULL>integer</NULL>
			<NULL>logtalk_compile</NULL>
			<NULL>logtalk_library_path</NULL>
			<NULL>logtalk_load</NULL>
			<NULL>meta_predicate</NULL>
			<NULL>mode</NULL>
			<NULL>nl</NULL>
			<NULL>nonvar</NULL>
			<NULL>number</NULL>
			<NULL>number_chars</NULL>
			<NULL>number_codes</NULL>
			<NULL>object</NULL>
			<NULL>object_property</NULL>
			<NULL>once</NULL>
			<NULL>op</NULL>
			<NULL>open</NULL>
			<NULL>parameter</NULL>
			<NULL>peek_byte</NULL>
			<NULL>peek_char</NULL>
			<NULL>peek_code</NULL>
			<NULL>phrase</NULL>
			<NULL>predicate_property</NULL>
			<NULL>private</NULL>
			<NULL>protected</NULL>
			<NULL>protocol</NULL>
			<NULL>protocol_property</NULL>
			<NULL>public</NULL>
			<NULL>put_byte</NULL>
			<NULL>put_char</NULL>
			<NULL>put_code</NULL>
			<NULL>read</NULL>
			<NULL>read_term</NULL>
			<NULL>repeat</NULL>
			<NULL>retract</NULL>
			<NULL>retractall</NULL>
			<NULL>self</NULL>
			<NULL>sender</NULL>
			<NULL>setof</NULL>
			<NULL>set_input</NULL>
			<NULL>set_logtalk_flag</NULL>
			<NULL>set_output</NULL>
			<NULL>set_prolog_flag</NULL>
			<NULL>set_stream_position</NULL>
			<NULL>specializes</NULL>
			<NULL>specializes_class</NULL>
			<NULL>stream_property</NULL>
			<NULL>sub_atom</NULL>
			<NULL>synchronized</NULL>
			<NULL>term_expansion</NULL>
			<NULL>this</NULL>
			<NULL>threaded</NULL>
			<NULL>threaded_call</NULL>
			<NULL>threaded_once</NULL>
			<NULL>threaded_ignore</NULL>
			<NULL>threaded_race</NULL>
			<NULL>threaded_exit</NULL>
			<NULL>threaded_peek</NULL>
			<NULL>threaded_wait</NULL>
			<NULL>threaded_notify</NULL>
			<NULL>throw</NULL>
			<NULL>true</NULL>
			<NULL>unify_with_occurs_check</NULL>
			<NULL>uses</NULL>
			<NULL>var</NULL>
			<NULL>write</NULL>
			<NULL>writeq</NULL>
			<NULL>write_canonical</NULL>

		</KEYWORDS>
		
	</RULES>

	<RULES SET="ENTITY_RELATIONS" IGNORE_CASE="FALSE">
		<SPAN TYPE="KEYWORD1" NO_LINE_BREAK="FALSE" DELEGATE="ENTITY_NAMES">
			<BEGIN>instantiates(</BEGIN>
			<END>)</END>
		</SPAN>
		<SPAN TYPE="KEYWORD1" NO_LINE_BREAK="FALSE" DELEGATE="ENTITY_NAMES">
			<BEGIN>specializes(</BEGIN>
			<END>)</END>
		</SPAN>
		<SPAN TYPE="KEYWORD1" NO_LINE_BREAK="FALSE" DELEGATE="ENTITY_NAMES">
			<BEGIN>extends(</BEGIN>
			<END>)</END>
		</SPAN>
		<SPAN TYPE="KEYWORD1" NO_LINE_BREAK="FALSE" DELEGATE="ENTITY_NAMES">
			<BEGIN>imports(</BEGIN>
			<END>)</END>
		</SPAN>
		<SPAN TYPE="KEYWORD1" NO_LINE_BREAK="FALSE" DELEGATE="ENTITY_NAMES">
			<BEGIN>implements(</BEGIN>
			<END>)</END>
		</SPAN>
	</RULES>


	<RULES SET="MODE" IGNORE_CASE="FALSE">
	
		<!-- Mode operators -->
		<SEQ TYPE="OPERATOR">+</SEQ>	
		<SEQ TYPE="OPERATOR">-</SEQ>
		<SEQ TYPE="OPERATOR">?</SEQ>
		<SEQ TYPE="OPERATOR">@</SEQ>

		<KEYWORDS AT_WORD_START="TRUE">
			<FUNCTION>zero</FUNCTION>
			<FUNCTION>zero_or_one</FUNCTION>
			<FUNCTION>zero_or_more</FUNCTION>
			<FUNCTION>one</FUNCTION>
			<FUNCTION>one_or_more</FUNCTION>
			<FUNCTION>error</FUNCTION>
		</KEYWORDS>

	</RULES>

 
	<RULES SET="INFO" IGNORE_CASE="FALSE" HIGHLIGHT_DIGITS="FALSE">

		<SPAN TYPE="LITERAL1" NO_LINE_BREAK="TRUE">
			<BEGIN>'</BEGIN>
			<END>'</END>
		</SPAN>

		<KEYWORDS>
			<!-- Key is Value -->
			<FUNCTION>is</FUNCTION>
		</KEYWORDS>

	</RULES>

	
	<RULES SET="PIs" IGNORE_CASE="FALSE" HIGHLIGHT_DIGITS="FALSE">	
	</RULES>


	<RULES SET="ENTITY_NAMES" IGNORE_CASE="FALSE">
	</RULES>


	<RULES SET="DIRECTIVE_CONTENTS" IGNORE_CASE="FALSE" HIGHLIGHT_DIGITS="FALSE">	
	</RULES>


	<RULES SET="PROLOG" IGNORE_CASE="FALSE">	
	</RULES>

</MODE>
