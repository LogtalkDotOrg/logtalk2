<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE syntax SYSTEM "syntax.dtd">
<syntax>

	<head>
		<name>Logtalk</name>
		<charsintokens>
			<![CDATA[_0987654321abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ{}-]]>
		</charsintokens> 
		<charsdelimitingtokens><![CDATA[ []()]]></charsdelimitingtokens>
	</head>

	<states>
	
		<default id="Base" color="#000" inverted-color="#fff">

			<keywords id="Variables" color="#848484" useforautocomplete="no">
				<regex>[^[:lower:]]([A-Z_][A-Za-z0-9_]*)[^[:alnum:]]</regex>
			</keywords>

			<keywords id="Directives" color="#881280">
				<regex>\:\-[[:space:]](object)\(</regex>			
				<regex>\:\-[[:space:]](protocol)\(</regex>			
				<regex>\:\-[[:space:]](category)\(</regex>			
				<regex>\:\-[[:space:]](end_(object|protocol|category))\.</regex>			
				<regex>\:\-[[:space:]](initialization)\(</regex>			
				<regex>\:\-[[:space:]](info)\(</regex>			
				<regex>\:\-[[:space:]](mode)\(</regex>			
				<regex>\:\-[[:space:]](dynamic)\(</regex>			
				<regex>\:\-[[:space:]](dynamic)\.</regex>			
				<regex>\:\-[[:space:]](discontiguous)\(</regex>			
				<regex>\:\-[[:space:]](p(ublic|r(otected|ivate)))\(</regex>			
				<regex>\:\-[[:space:]](metapredicate)\(</regex>			
				<regex>\:\-[[:space:]](op)\(</regex>			
				<regex>\:\-[[:space:]](calls)\(</regex>			
				<regex>\:\-[[:space:]](uses)\(</regex>			
			</keywords>

			<keywords id="Entity Relations" color="#881280">
				<regex>[^A-Za-z0-9_](instantiates)\(</regex>
				<regex>[^A-Za-z0-9_](specializes)\(</regex>
				<regex>[^A-Za-z0-9_](extends)\(</regex>
				<regex>[^A-Za-z0-9_](imp(orts|lements))\(</regex>
			</keywords>

			<keywords id="Message Sending Operators" color="#0000ff" useforautocomplete="no">
				<regex>(::)</regex>			
				<regex>(\^\^)</regex>
			</keywords>

			<keywords id="External Call" color="#0000ff" useforautocomplete="no">
				<regex>(\{)</regex>			
				<regex>(\})</regex>
			</keywords>

			<keywords id="Control Constructs" color="#1A1AA6">
				<regex>[^A-Za-z0-9_](ca(ll|tch))\(</regex>
				<regex>[^A-Za-z0-9_](throw)\(</regex>
				<regex>[^A-Za-z0-9_](true)[^A-Za-z0-9_]</regex>
				<regex>[^A-Za-z0-9_](fail)[^A-Za-z0-9_]</regex>
				<regex>[[:space:]]+(--&gt;)[[:space:]]+</regex>			
				<regex>[[:space:]]+(-&gt;)[[:space:]]+</regex>
				<regex>(!)</regex>
			</keywords>

			<keywords id="Built-in Methods" color="#1A1AA6">
				<regex>[^A-Za-z0-9_](parameter)\(</regex>
				<regex>[^A-Za-z0-9_](se(lf|nder))\(</regex>
				<regex>[^A-Za-z0-9_](this)\(</regex>
				<regex>[^A-Za-z0-9_](current_predicate)\(</regex>
				<regex>[^A-Za-z0-9_](predicate_property)\(</regex>
				<regex>[^A-Za-z0-9_](abolish)\(</regex>
				<regex>[^A-Za-z0-9_](assert(a|z))\(</regex>
				<regex>[^A-Za-z0-9_](clause)\(</regex>
				<regex>[^A-Za-z0-9_](retract(all)?)\(</regex>
				<regex>[^A-Za-z0-9_]((bag|set)of)\(</regex>
				<regex>[^A-Za-z0-9_](f(ind|or)all)\(</regex>
				<regex>[^A-Za-z0-9_](before)\(</regex>
				<regex>[^A-Za-z0-9_](after)\(</regex>
				<regex>[^A-Za-z0-9_](phrase)\(</regex>
			</keywords>

			<keywords id="Built-in Predicates" color="#1A1AA6">
				<regex>[^A-Za-z0-9_](current_(object|protocol|category|event))\(</regex>
				<regex>[^A-Za-z0-9_](create_(object|protocol|category))\(</regex>
				<regex>[^A-Za-z0-9_]((object|protocol|category)_property)\(</regex>
				<regex>[^A-Za-z0-9_](abolish_(object|protocol|category|events))\(</regex>
				<regex>[^A-Za-z0-9_](extends_(object|protocol))\(</regex>
				<regex>[^A-Za-z0-9_](implements_protocol)\(</regex>
				<regex>[^A-Za-z0-9_]((instantiates|specializes)_class)\(</regex>
				<regex>[^A-Za-z0-9_](imports_category)\(</regex>
				<regex>[^A-Za-z0-9_](define_events)\(</regex>
				<regex>[^A-Za-z0-9_]((set|current)_logtalk_flag)\(</regex>
				<regex>[^A-Za-z0-9_](logtalk_(compile|load))\(</regex>
				<regex>[^A-Za-z0-9_](forall)\(</regex>
				<!-- <regex>[^A-Za-z0-9_](retractall)\(</regex> -->
			</keywords>

			<keywords id="Other Built-in Predicates" color="#1A1AA6">
				<!-- Term unification -->
				<regex>[[:space:]]+(=)[[:space:]]+</regex>
				<regex>[[:space:]]+(\\=)[[:space:]]+</regex>
				<regex>[^A-Za-z0-9_](unify_with_occurs_check)\(</regex>
				<!-- Term testing -->
				<regex>[^A-Za-z0-9_](atom(ic)?)\(</regex>
				<regex>[^A-Za-z0-9_](integer)\(</regex>
				<regex>[^A-Za-z0-9_](float)\(</regex>
				<regex>[^A-Za-z0-9_](compound)\(</regex>
				<regex>[^A-Za-z0-9_]((non)?var)\(</regex>
				<regex>[^A-Za-z0-9_](number)\(</regex>
				<!-- Term comparison -->
				<regex>[[:space:]]+(==)[[:space:]]+</regex>
				<regex>[[:space:]]+(\\==)[[:space:]]+</regex>
				<regex>[[:space:]]+(@=&lt;)[[:space:]]+</regex>
				<regex>[[:space:]]+(@&lt;)[[:space:]]+</regex>
				<regex>[[:space:]]+(@&gt;=)[[:space:]]+</regex>
				<regex>[[:space:]]+(@&gt;)regex+</regex>
				<!-- Term creation and decomposition -->
				<regex>[^A-Za-z0-9_](functor)\(</regex>
				<regex>[^A-Za-z0-9_](arg)\(</regex>
				<regex>[[:space:]]+(=\.\.)[[:space:]]+</regex>
				<regex>[^A-Za-z0-9_](copy_term)\(</regex>
				<!-- Arithemtic evaluation -->
				<regex>[[:space:]]+(is)[[:space:]]+</regex>
				<!-- Arithemtic comparison -->
				<regex>[[:space:]]+(=:=)[[:space:]]+</regex>
				<regex>[[:space:]]+(=\=)[[:space:]]+</regex>
				<regex>[[:space:]]+(&lt;)[[:space:]]+</regex>
				<regex>[[:space:]]+(=&lt;)[[:space:]]+</regex>
				<regex>[[:space:]]+(&gt;)regex+</regex>
				<regex>[[:space:]]+(&gt;=)[[:space:]]+</regex>
				<!-- Evaluable functors -->
				<regex>[[:space:]]+(\+)[[:space:]]+</regex>
				<regex>[[:space:]]+(\-)[[:space:]]+</regex>
				<regex>[[:space:]]+(\*)[[:space:]]+</regex>
				<regex>[[:space:]]+(//)[[:space:]]+</regex>
				<regex>[[:space:]]+(/)[[:space:]]+</regex>
				<regex>[[:space:]]+(rem)[[:space:]]+</regex>
				<regex>[[:space:]]+(mod)[[:space:]]+</regex>
				<regex>[^A-Za-z0-9_](rem)\(</regex>
				<regex>[^A-Za-z0-9_](mod)\(</regex>
				<regex>[^A-Za-z0-9_](abs)\(</regex>
				<regex>[^A-Za-z0-9_](sign)\(</regex>
				<regex>[^A-Za-z0-9_](float(_(integer|fractional)_part)?)\(</regex>
				<regex>[^A-Za-z0-9_](floor)\(</regex>
				<regex>[^A-Za-z0-9_](truncate)\(</regex>
				<regex>[^A-Za-z0-9_](round)\(</regex>
				<regex>[^A-Za-z0-9_](ceiling)\(</regex>
				<!-- Other arithemtic functors -->
				<regex>[[:space:]]+(\*\*)[[:space:]]+</regex>
				<regex>[^A-Za-z0-9_](sin)\(</regex>
				<regex>[^A-Za-z0-9_](cos)\(</regex>
				<regex>[^A-Za-z0-9_](atan)\(</regex>
				<regex>[^A-Za-z0-9_](exp)\(</regex>
				<regex>[^A-Za-z0-9_](log)\(</regex>
				<regex>[^A-Za-z0-9_](sqrt)\(</regex>
				<!-- Bitwise functors -->
				<regex>[[:space:]]+(&gt;&gt;)[[:space:]]+</regex>
				<regex>[[:space:]]+(&lt;&lt;)[[:space:]]+</regex>
				<regex>[[:space:]]+(/\\)[[:space:]]+</regex>
				<regex>[[:space:]]+(\\/)[[:space:]]+</regex>
				<regex>[[:space:]]+(\\)[[:space:]]+</regex>
				<!-- Stream selection and control -->
				<regex>[^A-Za-z0-9_](current_(input|output))\(</regex>
				<regex>[^A-Za-z0-9_](set_(input|output))\(</regex>
				<regex>[^A-Za-z0-9_](open)\(</regex>
				<regex>[^A-Za-z0-9_](close)\(</regex>
				<regex>[^A-Za-z0-9_](flush_output)\(</regex>
				<regex>[^A-Za-z0-9_](stream_property)\(</regex>
				<regex>[^A-Za-z0-9_](at_end_of_stream)\(</regex>
				<regex>[^A-Za-z0-9_](set_stream_position)\(</regex>
				<regex>[^A-Za-z0-9_](flush_output)[^A-Za-z0-9_]</regex>
				<regex>[^A-Za-z0-9_](at_end_of_stream)[^A-Za-z0-9_]</regex>
				<!-- Character input/output -->
				<regex>[^A-Za-z0-9_](get_(char|code))\(</regex>
				<regex>[^A-Za-z0-9_](peek_(char|code))\(</regex>
				<regex>[^A-Za-z0-9_](put_(char|code))\(</regex>
				<regex>[^A-Za-z0-9_](nl)\(</regex>
				<regex>[^A-Za-z0-9_](nl)[^A-Za-z0-9_]</regex>
				<!-- Byte input/output -->
				<regex>[^A-Za-z0-9_]((get|peek|put)_byte)\(</regex>
				<!-- Term input/output -->
				<regex>[^A-Za-z0-9_](read(_term)?)\(</regex>
				<regex>[^A-Za-z0-9_](write(q)?)\(</regex>
				<regex>[^A-Za-z0-9_](write_(canonical|term))\(</regex>
				<regex>[^A-Za-z0-9_]((current_)?op)\(</regex>
				<regex>[^A-Za-z0-9_]((current_)?char_conversion)\(</regex>
				<!-- Logic and control -->
				<regex>(\\\+)[[:space:]]+</regex>
				<regex>[^A-Za-z0-9_](once)\(</regex>
				<regex>[^A-Za-z0-9_](repeat)[^A-Za-z0-9_]</regex>
				<!-- Atomic term processing -->
				<regex>[^A-Za-z0-9_](atom_(length|concat|chars|codes))\(</regex>
				<regex>[^A-Za-z0-9_](sub_atom)\(</regex>
				<regex>[^A-Za-z0-9_](char_code)\(</regex>
				<regex>[^A-Za-z0-9_](number_(chars|codes))\(</regex>
				<!-- Implementation defined hooks functions -->
				<regex>[^A-Za-z0-9_]((set|current)_prolog_flag)\(</regex>
				<regex>[^A-Za-z0-9_](halt)\(</regex>
				<regex>[^A-Za-z0-9_](halt)[^A-Za-z0-9_]</regex>
			</keywords>

			<keywords id="Numbers" color="#bf4b18" useforautocomplete="no">
				<regex>([0-9]+((\.[0-9]+)?([eE][-+][0-9]+)?)?)</regex>
				<regex>(0b[0-1]+)</regex>
				<regex>(0o[0-7]+)</regex>
				<regex>(0x[0-9a-fA-F]+)</regex>
				<regex>(0'[0-9a-zA-Z])</regex>
			</keywords>

		</default>

		<state id="Strings" color="#881314" useforautocomplete="no">
			<begin><regex>"</regex></begin>
			<end><regex>"</regex></end>
		</state>

		<state id="Quoted Atoms" color="#881314" useforautocomplete="no">
			<begin><regex>(?&lt;!0)'</regex></begin>
			<end><regex>'</regex></end>
		</state>

		<state id="Comment" color="#236E25" font-style="italic" useforautocomplete="no">
			<begin><regex>/\*</regex></begin>
			<end><regex>\*/</regex></end>
		</state>
		
		<state id="SingleComment" color="#236E25" font-style="italic" useforautocomplete="no">
			<begin><regex>%</regex></begin>
			<end><regex>[\n\r]</regex></end>
		</state>

	</states>

</syntax>