================================================================
Logtalk - Open source object-oriented logic programming language
Release 2.42.2

Copyright (c) 1998-2010 Paulo Moura.        All Rights Reserved.
Logtalk is free software.  You can redistribute it and/or modify
it under the terms of the "Artistic License 2.0" as published by 
The Perl Foundation. Consult the "LICENSE.txt" file for details.
================================================================


% start by loading the example:

| ?- logtalk_load(coinduction(loader)).
...


% an elementary coinductive predicate:

| ?- simple::p.
true ;
false.

% similar:

| ?- simple::p(hoho).
true ;
false.

| ?- simple::p(hoho, X).
X = hoho ;
false.


% the following goal is true for any cyclic list containing only ones:

| ?- L = [1| L], binary::p(L).
L = [1|**] ;
false.

% ... or zeros:

| ?- L = [0| L], binary::p(L).
L = [0|**] ;
false.

% or a repetition of a pattern of ones and zeros:

| ?- L = [1,0,1| L], binary::p(L).
L = [1, 0, 1|**] ;
false.

% but not all solutions can be returned:

| ?- binary::p(X).
X = [0, 0|**] ;
X = [0, 1, 1|**] ;
X = [0, 1, 0|**] ;
X = [1, 1|**] ;
X = [1, 0, 0|**] ;
X = [1, 0, 1|**] ;
false.


% infinite streams example:

| ?- streams::nat_stream([0, s(0), s(s(0))| T]).
T = [s(s(0))|**] ;
T = [s(0), s(s(0))|**] ;
T = [0, s(0), s(s(0))|**] ;
false.

|?- X = [0, 1, 1, 0| X], streams::bit_stream(X).
X = [0, 1, 1, 0|**] ;
false.


% list membership example:

| ?- X = [1, 2, 3| X], lists::comember(2, X).
X = [1, 2, 3|**] ;
X = [1, 2, 3|**] ;
X = [1, 2, 3|**] ;
...

| ?- X = [1, 2, 3, 1, 2, 3], lists::comember(2, X).
false.

% lack of Prolog support for tabling of rational terms prevents getting
% the three recurring list members (1, 2, and 3) in the following query:

| ?- X = [1, 2, 3| X], lists::comember(Y, X).
X = [1, 2, 3|**],
Y = 1 ;
X = [1, 2, 3|**],
Y = 1 ;
X = [1, 2, 3|**],
Y = 1 ;
...

| ?- X = [0, s(0), s(s(0))], lists::comember(s(0), X).
false.

| ?- X = [0, s(0), s(s(0))| X], lists::comember(s(0), X).
X = [0, s(0), s(s(0))|**] ;
X = [0, s(0), s(s(0))|**] ;
X = [0, s(0), s(s(0))|**] ;
...

% list append example:

| ?- Y = [4,5,6| Y], lists::append([1,2,3], Y, Z).
Y = [4, 5, 6|**],
Z = [1, 2, 3, 4, 5, 6|**].

| ?- X = [1,2,3| X], Y = [3,4| Y], lists::append(X, Y, Z).
X = [1, 2, 3|**],
Y = [3, 4|**],
Z = [1, 2, 3, 1|**] ;
false.

| ?- Z = [1,2| Z], lists::append(X, Y, Z).
Z = [1, 2|**],
X = [],
Y = [1, 2|**] ;
Z = [1, 2|**],
X = [1],
Y = [2, 1|**] ;
Z = [1, 2|**],
X = [1, 2, 1|**] ;
Z = [1, 2|**],
X = [1, 2],
Y = [1, 2|**] ;
false.


% list non-smembership example:

| ?- X = [1,2,3], lists::absent(2, X).
false.

| ?- X = [1,2,3], lists::absent(4, X).
false.

| ?- X = [1,2,3| X], lists::absent(4, X).
X = [1, 2, 3|**] ;
false.

| ?- X = [1,2,3| X], lists::absent(2, X).
false.


% omega-automaton example:

| ?- automata::automata(X, s0).
X = [a, b, c, d, a|**] ;
X = [a, b, e, a|**] ;
false.


% module 4 counter example:
% (not working; needs a Prolog tabling implementation supporting cyclic terms!)

| ?- counter::verify.
true.


% nested automata example:
% (partially working; needs a Prolog tabling implementation supporting cyclic terms!)

| ?- nested::state(s0, X), lists::absent(s2, X).
X = [s0, s1, s1|**] ;
X = [s0, s3|**] ;
false.


% timed automata example:

| ?- train::driver(s0, s0, s0, X, R).
X = [approach, lower, down, in, out, exit, raise, approach, up|...],
R = [ (approach, 0), (lower, 1.0), (down, _G7855), (in, _G7861), (out, _G7867), (exit, _G7873), (raise, _G7879), (approach, _G7885), (..., ...)|...] ;
X = [approach, lower, down, in, out, exit, raise, up, approach|...],
R = [ (approach, 0), (lower, 1.0), (down, _G7737), (in, _G7743), (out, _G7749), (exit, _G7755), (raise, _G7761), (up, _G7767), (..., ...)|...],
{_G7783>0.0, _G7792=_G7743+_G7808+_G7805+_G7802+_G7799+_G7783, _G7813=_G7743+_G7808+_G7805+_G7802, _G7799>1.0, _G7799<2.0, _G7767=... + ... + _G7799, _G7864=... + ..., ... > ..., ..., ...} ;
false.
